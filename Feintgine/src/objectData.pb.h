// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: objectData.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_objectData_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_objectData_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021002 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_objectData_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_objectData_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_objectData_2eproto;
class Proc_Brush;
struct Proc_BrushDefaultTypeInternal;
extern Proc_BrushDefaultTypeInternal _Proc_Brush_default_instance_;
class Proc_ColiderBox;
struct Proc_ColiderBoxDefaultTypeInternal;
extern Proc_ColiderBoxDefaultTypeInternal _Proc_ColiderBox_default_instance_;
class Proc_Layer;
struct Proc_LayerDefaultTypeInternal;
extern Proc_LayerDefaultTypeInternal _Proc_Layer_default_instance_;
class Proc_LoadObject;
struct Proc_LoadObjectDefaultTypeInternal;
extern Proc_LoadObjectDefaultTypeInternal _Proc_LoadObject_default_instance_;
class Proc_Object;
struct Proc_ObjectDefaultTypeInternal;
extern Proc_ObjectDefaultTypeInternal _Proc_Object_default_instance_;
class Proc_OwnSprite;
struct Proc_OwnSpriteDefaultTypeInternal;
extern Proc_OwnSpriteDefaultTypeInternal _Proc_OwnSprite_default_instance_;
class Proc_Scene;
struct Proc_SceneDefaultTypeInternal;
extern Proc_SceneDefaultTypeInternal _Proc_Scene_default_instance_;
class Proc_SpotLight;
struct Proc_SpotLightDefaultTypeInternal;
extern Proc_SpotLightDefaultTypeInternal _Proc_SpotLight_default_instance_;
class Proc_Sprite;
struct Proc_SpriteDefaultTypeInternal;
extern Proc_SpriteDefaultTypeInternal _Proc_Sprite_default_instance_;
class Proc_Vec2;
struct Proc_Vec2DefaultTypeInternal;
extern Proc_Vec2DefaultTypeInternal _Proc_Vec2_default_instance_;
class Proc_Vec3;
struct Proc_Vec3DefaultTypeInternal;
extern Proc_Vec3DefaultTypeInternal _Proc_Vec3_default_instance_;
class Proc_Vec4;
struct Proc_Vec4DefaultTypeInternal;
extern Proc_Vec4DefaultTypeInternal _Proc_Vec4_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::Proc_Brush* Arena::CreateMaybeMessage<::Proc_Brush>(Arena*);
template<> ::Proc_ColiderBox* Arena::CreateMaybeMessage<::Proc_ColiderBox>(Arena*);
template<> ::Proc_Layer* Arena::CreateMaybeMessage<::Proc_Layer>(Arena*);
template<> ::Proc_LoadObject* Arena::CreateMaybeMessage<::Proc_LoadObject>(Arena*);
template<> ::Proc_Object* Arena::CreateMaybeMessage<::Proc_Object>(Arena*);
template<> ::Proc_OwnSprite* Arena::CreateMaybeMessage<::Proc_OwnSprite>(Arena*);
template<> ::Proc_Scene* Arena::CreateMaybeMessage<::Proc_Scene>(Arena*);
template<> ::Proc_SpotLight* Arena::CreateMaybeMessage<::Proc_SpotLight>(Arena*);
template<> ::Proc_Sprite* Arena::CreateMaybeMessage<::Proc_Sprite>(Arena*);
template<> ::Proc_Vec2* Arena::CreateMaybeMessage<::Proc_Vec2>(Arena*);
template<> ::Proc_Vec3* Arena::CreateMaybeMessage<::Proc_Vec3>(Arena*);
template<> ::Proc_Vec4* Arena::CreateMaybeMessage<::Proc_Vec4>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

// ===================================================================

class Proc_Vec2 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Proc_Vec2) */ {
 public:
  inline Proc_Vec2() : Proc_Vec2(nullptr) {}
  ~Proc_Vec2() override;
  explicit PROTOBUF_CONSTEXPR Proc_Vec2(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Proc_Vec2(const Proc_Vec2& from);
  Proc_Vec2(Proc_Vec2&& from) noexcept
    : Proc_Vec2() {
    *this = ::std::move(from);
  }

  inline Proc_Vec2& operator=(const Proc_Vec2& from) {
    CopyFrom(from);
    return *this;
  }
  inline Proc_Vec2& operator=(Proc_Vec2&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Proc_Vec2& default_instance() {
    return *internal_default_instance();
  }
  static inline const Proc_Vec2* internal_default_instance() {
    return reinterpret_cast<const Proc_Vec2*>(
               &_Proc_Vec2_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Proc_Vec2& a, Proc_Vec2& b) {
    a.Swap(&b);
  }
  inline void Swap(Proc_Vec2* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Proc_Vec2* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Proc_Vec2* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Proc_Vec2>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Proc_Vec2& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Proc_Vec2& from) {
    Proc_Vec2::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Proc_Vec2* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Proc_Vec2";
  }
  protected:
  explicit Proc_Vec2(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueXFieldNumber = 1,
    kValueYFieldNumber = 2,
  };
  // float valueX = 1;
  void clear_valuex();
  float valuex() const;
  void set_valuex(float value);
  private:
  float _internal_valuex() const;
  void _internal_set_valuex(float value);
  public:

  // float valueY = 2;
  void clear_valuey();
  float valuey() const;
  void set_valuey(float value);
  private:
  float _internal_valuey() const;
  void _internal_set_valuey(float value);
  public:

  // @@protoc_insertion_point(class_scope:Proc_Vec2)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float valuex_;
    float valuey_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_objectData_2eproto;
};
// -------------------------------------------------------------------

class Proc_Vec3 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Proc_Vec3) */ {
 public:
  inline Proc_Vec3() : Proc_Vec3(nullptr) {}
  ~Proc_Vec3() override;
  explicit PROTOBUF_CONSTEXPR Proc_Vec3(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Proc_Vec3(const Proc_Vec3& from);
  Proc_Vec3(Proc_Vec3&& from) noexcept
    : Proc_Vec3() {
    *this = ::std::move(from);
  }

  inline Proc_Vec3& operator=(const Proc_Vec3& from) {
    CopyFrom(from);
    return *this;
  }
  inline Proc_Vec3& operator=(Proc_Vec3&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Proc_Vec3& default_instance() {
    return *internal_default_instance();
  }
  static inline const Proc_Vec3* internal_default_instance() {
    return reinterpret_cast<const Proc_Vec3*>(
               &_Proc_Vec3_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Proc_Vec3& a, Proc_Vec3& b) {
    a.Swap(&b);
  }
  inline void Swap(Proc_Vec3* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Proc_Vec3* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Proc_Vec3* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Proc_Vec3>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Proc_Vec3& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Proc_Vec3& from) {
    Proc_Vec3::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Proc_Vec3* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Proc_Vec3";
  }
  protected:
  explicit Proc_Vec3(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueXFieldNumber = 1,
    kValueYFieldNumber = 2,
    kValueZFieldNumber = 3,
  };
  // float valueX = 1;
  void clear_valuex();
  float valuex() const;
  void set_valuex(float value);
  private:
  float _internal_valuex() const;
  void _internal_set_valuex(float value);
  public:

  // float valueY = 2;
  void clear_valuey();
  float valuey() const;
  void set_valuey(float value);
  private:
  float _internal_valuey() const;
  void _internal_set_valuey(float value);
  public:

  // float valueZ = 3;
  void clear_valuez();
  float valuez() const;
  void set_valuez(float value);
  private:
  float _internal_valuez() const;
  void _internal_set_valuez(float value);
  public:

  // @@protoc_insertion_point(class_scope:Proc_Vec3)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float valuex_;
    float valuey_;
    float valuez_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_objectData_2eproto;
};
// -------------------------------------------------------------------

class Proc_Vec4 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Proc_Vec4) */ {
 public:
  inline Proc_Vec4() : Proc_Vec4(nullptr) {}
  ~Proc_Vec4() override;
  explicit PROTOBUF_CONSTEXPR Proc_Vec4(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Proc_Vec4(const Proc_Vec4& from);
  Proc_Vec4(Proc_Vec4&& from) noexcept
    : Proc_Vec4() {
    *this = ::std::move(from);
  }

  inline Proc_Vec4& operator=(const Proc_Vec4& from) {
    CopyFrom(from);
    return *this;
  }
  inline Proc_Vec4& operator=(Proc_Vec4&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Proc_Vec4& default_instance() {
    return *internal_default_instance();
  }
  static inline const Proc_Vec4* internal_default_instance() {
    return reinterpret_cast<const Proc_Vec4*>(
               &_Proc_Vec4_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Proc_Vec4& a, Proc_Vec4& b) {
    a.Swap(&b);
  }
  inline void Swap(Proc_Vec4* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Proc_Vec4* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Proc_Vec4* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Proc_Vec4>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Proc_Vec4& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Proc_Vec4& from) {
    Proc_Vec4::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Proc_Vec4* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Proc_Vec4";
  }
  protected:
  explicit Proc_Vec4(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueXFieldNumber = 1,
    kValueYFieldNumber = 2,
    kValueZFieldNumber = 3,
    kValueWFieldNumber = 4,
  };
  // float valueX = 1;
  void clear_valuex();
  float valuex() const;
  void set_valuex(float value);
  private:
  float _internal_valuex() const;
  void _internal_set_valuex(float value);
  public:

  // float valueY = 2;
  void clear_valuey();
  float valuey() const;
  void set_valuey(float value);
  private:
  float _internal_valuey() const;
  void _internal_set_valuey(float value);
  public:

  // float valueZ = 3;
  void clear_valuez();
  float valuez() const;
  void set_valuez(float value);
  private:
  float _internal_valuez() const;
  void _internal_set_valuez(float value);
  public:

  // float valueW = 4;
  void clear_valuew();
  float valuew() const;
  void set_valuew(float value);
  private:
  float _internal_valuew() const;
  void _internal_set_valuew(float value);
  public:

  // @@protoc_insertion_point(class_scope:Proc_Vec4)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float valuex_;
    float valuey_;
    float valuez_;
    float valuew_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_objectData_2eproto;
};
// -------------------------------------------------------------------

class Proc_SpotLight final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Proc_SpotLight) */ {
 public:
  inline Proc_SpotLight() : Proc_SpotLight(nullptr) {}
  ~Proc_SpotLight() override;
  explicit PROTOBUF_CONSTEXPR Proc_SpotLight(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Proc_SpotLight(const Proc_SpotLight& from);
  Proc_SpotLight(Proc_SpotLight&& from) noexcept
    : Proc_SpotLight() {
    *this = ::std::move(from);
  }

  inline Proc_SpotLight& operator=(const Proc_SpotLight& from) {
    CopyFrom(from);
    return *this;
  }
  inline Proc_SpotLight& operator=(Proc_SpotLight&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Proc_SpotLight& default_instance() {
    return *internal_default_instance();
  }
  static inline const Proc_SpotLight* internal_default_instance() {
    return reinterpret_cast<const Proc_SpotLight*>(
               &_Proc_SpotLight_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Proc_SpotLight& a, Proc_SpotLight& b) {
    a.Swap(&b);
  }
  inline void Swap(Proc_SpotLight* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Proc_SpotLight* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Proc_SpotLight* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Proc_SpotLight>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Proc_SpotLight& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Proc_SpotLight& from) {
    Proc_SpotLight::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Proc_SpotLight* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Proc_SpotLight";
  }
  protected:
  explicit Proc_SpotLight(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPosFieldNumber = 1,
    kColorFieldNumber = 2,
    kAtenuationFieldNumber = 3,
  };
  // .Proc_Vec2 pos = 1;
  bool has_pos() const;
  private:
  bool _internal_has_pos() const;
  public:
  void clear_pos();
  const ::Proc_Vec2& pos() const;
  PROTOBUF_NODISCARD ::Proc_Vec2* release_pos();
  ::Proc_Vec2* mutable_pos();
  void set_allocated_pos(::Proc_Vec2* pos);
  private:
  const ::Proc_Vec2& _internal_pos() const;
  ::Proc_Vec2* _internal_mutable_pos();
  public:
  void unsafe_arena_set_allocated_pos(
      ::Proc_Vec2* pos);
  ::Proc_Vec2* unsafe_arena_release_pos();

  // .Proc_Vec4 color = 2;
  bool has_color() const;
  private:
  bool _internal_has_color() const;
  public:
  void clear_color();
  const ::Proc_Vec4& color() const;
  PROTOBUF_NODISCARD ::Proc_Vec4* release_color();
  ::Proc_Vec4* mutable_color();
  void set_allocated_color(::Proc_Vec4* color);
  private:
  const ::Proc_Vec4& _internal_color() const;
  ::Proc_Vec4* _internal_mutable_color();
  public:
  void unsafe_arena_set_allocated_color(
      ::Proc_Vec4* color);
  ::Proc_Vec4* unsafe_arena_release_color();

  // .Proc_Vec3 atenuation = 3;
  bool has_atenuation() const;
  private:
  bool _internal_has_atenuation() const;
  public:
  void clear_atenuation();
  const ::Proc_Vec3& atenuation() const;
  PROTOBUF_NODISCARD ::Proc_Vec3* release_atenuation();
  ::Proc_Vec3* mutable_atenuation();
  void set_allocated_atenuation(::Proc_Vec3* atenuation);
  private:
  const ::Proc_Vec3& _internal_atenuation() const;
  ::Proc_Vec3* _internal_mutable_atenuation();
  public:
  void unsafe_arena_set_allocated_atenuation(
      ::Proc_Vec3* atenuation);
  ::Proc_Vec3* unsafe_arena_release_atenuation();

  // @@protoc_insertion_point(class_scope:Proc_SpotLight)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Proc_Vec2* pos_;
    ::Proc_Vec4* color_;
    ::Proc_Vec3* atenuation_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_objectData_2eproto;
};
// -------------------------------------------------------------------

class Proc_ColiderBox final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Proc_ColiderBox) */ {
 public:
  inline Proc_ColiderBox() : Proc_ColiderBox(nullptr) {}
  ~Proc_ColiderBox() override;
  explicit PROTOBUF_CONSTEXPR Proc_ColiderBox(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Proc_ColiderBox(const Proc_ColiderBox& from);
  Proc_ColiderBox(Proc_ColiderBox&& from) noexcept
    : Proc_ColiderBox() {
    *this = ::std::move(from);
  }

  inline Proc_ColiderBox& operator=(const Proc_ColiderBox& from) {
    CopyFrom(from);
    return *this;
  }
  inline Proc_ColiderBox& operator=(Proc_ColiderBox&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Proc_ColiderBox& default_instance() {
    return *internal_default_instance();
  }
  static inline const Proc_ColiderBox* internal_default_instance() {
    return reinterpret_cast<const Proc_ColiderBox*>(
               &_Proc_ColiderBox_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Proc_ColiderBox& a, Proc_ColiderBox& b) {
    a.Swap(&b);
  }
  inline void Swap(Proc_ColiderBox* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Proc_ColiderBox* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Proc_ColiderBox* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Proc_ColiderBox>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Proc_ColiderBox& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Proc_ColiderBox& from) {
    Proc_ColiderBox::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Proc_ColiderBox* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Proc_ColiderBox";
  }
  protected:
  explicit Proc_ColiderBox(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPosFieldNumber = 1,
    kDimFieldNumber = 2,
  };
  // .Proc_Vec2 pos = 1;
  bool has_pos() const;
  private:
  bool _internal_has_pos() const;
  public:
  void clear_pos();
  const ::Proc_Vec2& pos() const;
  PROTOBUF_NODISCARD ::Proc_Vec2* release_pos();
  ::Proc_Vec2* mutable_pos();
  void set_allocated_pos(::Proc_Vec2* pos);
  private:
  const ::Proc_Vec2& _internal_pos() const;
  ::Proc_Vec2* _internal_mutable_pos();
  public:
  void unsafe_arena_set_allocated_pos(
      ::Proc_Vec2* pos);
  ::Proc_Vec2* unsafe_arena_release_pos();

  // .Proc_Vec2 dim = 2;
  bool has_dim() const;
  private:
  bool _internal_has_dim() const;
  public:
  void clear_dim();
  const ::Proc_Vec2& dim() const;
  PROTOBUF_NODISCARD ::Proc_Vec2* release_dim();
  ::Proc_Vec2* mutable_dim();
  void set_allocated_dim(::Proc_Vec2* dim);
  private:
  const ::Proc_Vec2& _internal_dim() const;
  ::Proc_Vec2* _internal_mutable_dim();
  public:
  void unsafe_arena_set_allocated_dim(
      ::Proc_Vec2* dim);
  ::Proc_Vec2* unsafe_arena_release_dim();

  // @@protoc_insertion_point(class_scope:Proc_ColiderBox)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Proc_Vec2* pos_;
    ::Proc_Vec2* dim_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_objectData_2eproto;
};
// -------------------------------------------------------------------

class Proc_Sprite final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Proc_Sprite) */ {
 public:
  inline Proc_Sprite() : Proc_Sprite(nullptr) {}
  ~Proc_Sprite() override;
  explicit PROTOBUF_CONSTEXPR Proc_Sprite(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Proc_Sprite(const Proc_Sprite& from);
  Proc_Sprite(Proc_Sprite&& from) noexcept
    : Proc_Sprite() {
    *this = ::std::move(from);
  }

  inline Proc_Sprite& operator=(const Proc_Sprite& from) {
    CopyFrom(from);
    return *this;
  }
  inline Proc_Sprite& operator=(Proc_Sprite&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Proc_Sprite& default_instance() {
    return *internal_default_instance();
  }
  static inline const Proc_Sprite* internal_default_instance() {
    return reinterpret_cast<const Proc_Sprite*>(
               &_Proc_Sprite_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Proc_Sprite& a, Proc_Sprite& b) {
    a.Swap(&b);
  }
  inline void Swap(Proc_Sprite* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Proc_Sprite* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Proc_Sprite* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Proc_Sprite>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Proc_Sprite& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Proc_Sprite& from) {
    Proc_Sprite::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Proc_Sprite* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Proc_Sprite";
  }
  protected:
  explicit Proc_Sprite(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTexturePathFieldNumber = 1,
    kNameFieldNumber = 3,
    kPacketNameFieldNumber = 4,
    kDimFieldNumber = 2,
    kIsInvertFieldNumber = 5,
  };
  // string texturePath = 1;
  void clear_texturepath();
  const std::string& texturepath() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_texturepath(ArgT0&& arg0, ArgT... args);
  std::string* mutable_texturepath();
  PROTOBUF_NODISCARD std::string* release_texturepath();
  void set_allocated_texturepath(std::string* texturepath);
  private:
  const std::string& _internal_texturepath() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_texturepath(const std::string& value);
  std::string* _internal_mutable_texturepath();
  public:

  // string name = 3;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string packetName = 4;
  void clear_packetname();
  const std::string& packetname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_packetname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_packetname();
  PROTOBUF_NODISCARD std::string* release_packetname();
  void set_allocated_packetname(std::string* packetname);
  private:
  const std::string& _internal_packetname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_packetname(const std::string& value);
  std::string* _internal_mutable_packetname();
  public:

  // .Proc_Vec2 dim = 2;
  bool has_dim() const;
  private:
  bool _internal_has_dim() const;
  public:
  void clear_dim();
  const ::Proc_Vec2& dim() const;
  PROTOBUF_NODISCARD ::Proc_Vec2* release_dim();
  ::Proc_Vec2* mutable_dim();
  void set_allocated_dim(::Proc_Vec2* dim);
  private:
  const ::Proc_Vec2& _internal_dim() const;
  ::Proc_Vec2* _internal_mutable_dim();
  public:
  void unsafe_arena_set_allocated_dim(
      ::Proc_Vec2* dim);
  ::Proc_Vec2* unsafe_arena_release_dim();

  // bool isInvert = 5;
  void clear_isinvert();
  bool isinvert() const;
  void set_isinvert(bool value);
  private:
  bool _internal_isinvert() const;
  void _internal_set_isinvert(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Proc_Sprite)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr texturepath_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr packetname_;
    ::Proc_Vec2* dim_;
    bool isinvert_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_objectData_2eproto;
};
// -------------------------------------------------------------------

class Proc_OwnSprite final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Proc_OwnSprite) */ {
 public:
  inline Proc_OwnSprite() : Proc_OwnSprite(nullptr) {}
  ~Proc_OwnSprite() override;
  explicit PROTOBUF_CONSTEXPR Proc_OwnSprite(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Proc_OwnSprite(const Proc_OwnSprite& from);
  Proc_OwnSprite(Proc_OwnSprite&& from) noexcept
    : Proc_OwnSprite() {
    *this = ::std::move(from);
  }

  inline Proc_OwnSprite& operator=(const Proc_OwnSprite& from) {
    CopyFrom(from);
    return *this;
  }
  inline Proc_OwnSprite& operator=(Proc_OwnSprite&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Proc_OwnSprite& default_instance() {
    return *internal_default_instance();
  }
  static inline const Proc_OwnSprite* internal_default_instance() {
    return reinterpret_cast<const Proc_OwnSprite*>(
               &_Proc_OwnSprite_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Proc_OwnSprite& a, Proc_OwnSprite& b) {
    a.Swap(&b);
  }
  inline void Swap(Proc_OwnSprite* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Proc_OwnSprite* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Proc_OwnSprite* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Proc_OwnSprite>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Proc_OwnSprite& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Proc_OwnSprite& from) {
    Proc_OwnSprite::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Proc_OwnSprite* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Proc_OwnSprite";
  }
  protected:
  explicit Proc_OwnSprite(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProcSpriteFieldNumber = 1,
    kOffsetPosFieldNumber = 2,
    kOffsetScaleFieldNumber = 3,
    kColorFieldNumber = 4,
    kDepthFieldNumber = 5,
    kAngleFieldNumber = 6,
  };
  // .Proc_Sprite Proc_Sprite = 1;
  bool has_proc_sprite() const;
  private:
  bool _internal_has_proc_sprite() const;
  public:
  void clear_proc_sprite();
  const ::Proc_Sprite& proc_sprite() const;
  PROTOBUF_NODISCARD ::Proc_Sprite* release_proc_sprite();
  ::Proc_Sprite* mutable_proc_sprite();
  void set_allocated_proc_sprite(::Proc_Sprite* proc_sprite);
  private:
  const ::Proc_Sprite& _internal_proc_sprite() const;
  ::Proc_Sprite* _internal_mutable_proc_sprite();
  public:
  void unsafe_arena_set_allocated_proc_sprite(
      ::Proc_Sprite* proc_sprite);
  ::Proc_Sprite* unsafe_arena_release_proc_sprite();

  // .Proc_Vec2 offsetPos = 2;
  bool has_offsetpos() const;
  private:
  bool _internal_has_offsetpos() const;
  public:
  void clear_offsetpos();
  const ::Proc_Vec2& offsetpos() const;
  PROTOBUF_NODISCARD ::Proc_Vec2* release_offsetpos();
  ::Proc_Vec2* mutable_offsetpos();
  void set_allocated_offsetpos(::Proc_Vec2* offsetpos);
  private:
  const ::Proc_Vec2& _internal_offsetpos() const;
  ::Proc_Vec2* _internal_mutable_offsetpos();
  public:
  void unsafe_arena_set_allocated_offsetpos(
      ::Proc_Vec2* offsetpos);
  ::Proc_Vec2* unsafe_arena_release_offsetpos();

  // .Proc_Vec2 offsetScale = 3;
  bool has_offsetscale() const;
  private:
  bool _internal_has_offsetscale() const;
  public:
  void clear_offsetscale();
  const ::Proc_Vec2& offsetscale() const;
  PROTOBUF_NODISCARD ::Proc_Vec2* release_offsetscale();
  ::Proc_Vec2* mutable_offsetscale();
  void set_allocated_offsetscale(::Proc_Vec2* offsetscale);
  private:
  const ::Proc_Vec2& _internal_offsetscale() const;
  ::Proc_Vec2* _internal_mutable_offsetscale();
  public:
  void unsafe_arena_set_allocated_offsetscale(
      ::Proc_Vec2* offsetscale);
  ::Proc_Vec2* unsafe_arena_release_offsetscale();

  // .Proc_Vec4 color = 4;
  bool has_color() const;
  private:
  bool _internal_has_color() const;
  public:
  void clear_color();
  const ::Proc_Vec4& color() const;
  PROTOBUF_NODISCARD ::Proc_Vec4* release_color();
  ::Proc_Vec4* mutable_color();
  void set_allocated_color(::Proc_Vec4* color);
  private:
  const ::Proc_Vec4& _internal_color() const;
  ::Proc_Vec4* _internal_mutable_color();
  public:
  void unsafe_arena_set_allocated_color(
      ::Proc_Vec4* color);
  ::Proc_Vec4* unsafe_arena_release_color();

  // float depth = 5;
  void clear_depth();
  float depth() const;
  void set_depth(float value);
  private:
  float _internal_depth() const;
  void _internal_set_depth(float value);
  public:

  // optional float angle = 6;
  bool has_angle() const;
  private:
  bool _internal_has_angle() const;
  public:
  void clear_angle();
  float angle() const;
  void set_angle(float value);
  private:
  float _internal_angle() const;
  void _internal_set_angle(float value);
  public:

  // @@protoc_insertion_point(class_scope:Proc_OwnSprite)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::Proc_Sprite* proc_sprite_;
    ::Proc_Vec2* offsetpos_;
    ::Proc_Vec2* offsetscale_;
    ::Proc_Vec4* color_;
    float depth_;
    float angle_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_objectData_2eproto;
};
// -------------------------------------------------------------------

class Proc_Object final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Proc_Object) */ {
 public:
  inline Proc_Object() : Proc_Object(nullptr) {}
  ~Proc_Object() override;
  explicit PROTOBUF_CONSTEXPR Proc_Object(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Proc_Object(const Proc_Object& from);
  Proc_Object(Proc_Object&& from) noexcept
    : Proc_Object() {
    *this = ::std::move(from);
  }

  inline Proc_Object& operator=(const Proc_Object& from) {
    CopyFrom(from);
    return *this;
  }
  inline Proc_Object& operator=(Proc_Object&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Proc_Object& default_instance() {
    return *internal_default_instance();
  }
  static inline const Proc_Object* internal_default_instance() {
    return reinterpret_cast<const Proc_Object*>(
               &_Proc_Object_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Proc_Object& a, Proc_Object& b) {
    a.Swap(&b);
  }
  inline void Swap(Proc_Object* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Proc_Object* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Proc_Object* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Proc_Object>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Proc_Object& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Proc_Object& from) {
    Proc_Object::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Proc_Object* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Proc_Object";
  }
  protected:
  explicit Proc_Object(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProcSpriteListFieldNumber = 2,
    kLightListFieldNumber = 3,
    kColiderListFieldNumber = 4,
    kNameFieldNumber = 1,
  };
  // repeated .Proc_OwnSprite Proc_SpriteList = 2;
  int proc_spritelist_size() const;
  private:
  int _internal_proc_spritelist_size() const;
  public:
  void clear_proc_spritelist();
  ::Proc_OwnSprite* mutable_proc_spritelist(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Proc_OwnSprite >*
      mutable_proc_spritelist();
  private:
  const ::Proc_OwnSprite& _internal_proc_spritelist(int index) const;
  ::Proc_OwnSprite* _internal_add_proc_spritelist();
  public:
  const ::Proc_OwnSprite& proc_spritelist(int index) const;
  ::Proc_OwnSprite* add_proc_spritelist();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Proc_OwnSprite >&
      proc_spritelist() const;

  // repeated .Proc_SpotLight lightList = 3;
  int lightlist_size() const;
  private:
  int _internal_lightlist_size() const;
  public:
  void clear_lightlist();
  ::Proc_SpotLight* mutable_lightlist(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Proc_SpotLight >*
      mutable_lightlist();
  private:
  const ::Proc_SpotLight& _internal_lightlist(int index) const;
  ::Proc_SpotLight* _internal_add_lightlist();
  public:
  const ::Proc_SpotLight& lightlist(int index) const;
  ::Proc_SpotLight* add_lightlist();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Proc_SpotLight >&
      lightlist() const;

  // repeated .Proc_ColiderBox coliderList = 4;
  int coliderlist_size() const;
  private:
  int _internal_coliderlist_size() const;
  public:
  void clear_coliderlist();
  ::Proc_ColiderBox* mutable_coliderlist(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Proc_ColiderBox >*
      mutable_coliderlist();
  private:
  const ::Proc_ColiderBox& _internal_coliderlist(int index) const;
  ::Proc_ColiderBox* _internal_add_coliderlist();
  public:
  const ::Proc_ColiderBox& coliderlist(int index) const;
  ::Proc_ColiderBox* add_coliderlist();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Proc_ColiderBox >&
      coliderlist() const;

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:Proc_Object)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Proc_OwnSprite > proc_spritelist_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Proc_SpotLight > lightlist_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Proc_ColiderBox > coliderlist_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_objectData_2eproto;
};
// -------------------------------------------------------------------

class Proc_LoadObject final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Proc_LoadObject) */ {
 public:
  inline Proc_LoadObject() : Proc_LoadObject(nullptr) {}
  ~Proc_LoadObject() override;
  explicit PROTOBUF_CONSTEXPR Proc_LoadObject(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Proc_LoadObject(const Proc_LoadObject& from);
  Proc_LoadObject(Proc_LoadObject&& from) noexcept
    : Proc_LoadObject() {
    *this = ::std::move(from);
  }

  inline Proc_LoadObject& operator=(const Proc_LoadObject& from) {
    CopyFrom(from);
    return *this;
  }
  inline Proc_LoadObject& operator=(Proc_LoadObject&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Proc_LoadObject& default_instance() {
    return *internal_default_instance();
  }
  static inline const Proc_LoadObject* internal_default_instance() {
    return reinterpret_cast<const Proc_LoadObject*>(
               &_Proc_LoadObject_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Proc_LoadObject& a, Proc_LoadObject& b) {
    a.Swap(&b);
  }
  inline void Swap(Proc_LoadObject* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Proc_LoadObject* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Proc_LoadObject* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Proc_LoadObject>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Proc_LoadObject& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Proc_LoadObject& from) {
    Proc_LoadObject::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Proc_LoadObject* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Proc_LoadObject";
  }
  protected:
  explicit Proc_LoadObject(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRefabFieldNumber = 1,
    kPosFieldNumber = 2,
    kColorFieldNumber = 3,
    kScaleFieldNumber = 5,
    kAngleFieldNumber = 4,
  };
  // .Proc_Object refab = 1;
  bool has_refab() const;
  private:
  bool _internal_has_refab() const;
  public:
  void clear_refab();
  const ::Proc_Object& refab() const;
  PROTOBUF_NODISCARD ::Proc_Object* release_refab();
  ::Proc_Object* mutable_refab();
  void set_allocated_refab(::Proc_Object* refab);
  private:
  const ::Proc_Object& _internal_refab() const;
  ::Proc_Object* _internal_mutable_refab();
  public:
  void unsafe_arena_set_allocated_refab(
      ::Proc_Object* refab);
  ::Proc_Object* unsafe_arena_release_refab();

  // .Proc_Vec2 pos = 2;
  bool has_pos() const;
  private:
  bool _internal_has_pos() const;
  public:
  void clear_pos();
  const ::Proc_Vec2& pos() const;
  PROTOBUF_NODISCARD ::Proc_Vec2* release_pos();
  ::Proc_Vec2* mutable_pos();
  void set_allocated_pos(::Proc_Vec2* pos);
  private:
  const ::Proc_Vec2& _internal_pos() const;
  ::Proc_Vec2* _internal_mutable_pos();
  public:
  void unsafe_arena_set_allocated_pos(
      ::Proc_Vec2* pos);
  ::Proc_Vec2* unsafe_arena_release_pos();

  // .Proc_Vec4 color = 3;
  bool has_color() const;
  private:
  bool _internal_has_color() const;
  public:
  void clear_color();
  const ::Proc_Vec4& color() const;
  PROTOBUF_NODISCARD ::Proc_Vec4* release_color();
  ::Proc_Vec4* mutable_color();
  void set_allocated_color(::Proc_Vec4* color);
  private:
  const ::Proc_Vec4& _internal_color() const;
  ::Proc_Vec4* _internal_mutable_color();
  public:
  void unsafe_arena_set_allocated_color(
      ::Proc_Vec4* color);
  ::Proc_Vec4* unsafe_arena_release_color();

  // .Proc_Vec2 scale = 5;
  bool has_scale() const;
  private:
  bool _internal_has_scale() const;
  public:
  void clear_scale();
  const ::Proc_Vec2& scale() const;
  PROTOBUF_NODISCARD ::Proc_Vec2* release_scale();
  ::Proc_Vec2* mutable_scale();
  void set_allocated_scale(::Proc_Vec2* scale);
  private:
  const ::Proc_Vec2& _internal_scale() const;
  ::Proc_Vec2* _internal_mutable_scale();
  public:
  void unsafe_arena_set_allocated_scale(
      ::Proc_Vec2* scale);
  ::Proc_Vec2* unsafe_arena_release_scale();

  // float angle = 4;
  void clear_angle();
  float angle() const;
  void set_angle(float value);
  private:
  float _internal_angle() const;
  void _internal_set_angle(float value);
  public:

  // @@protoc_insertion_point(class_scope:Proc_LoadObject)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Proc_Object* refab_;
    ::Proc_Vec2* pos_;
    ::Proc_Vec4* color_;
    ::Proc_Vec2* scale_;
    float angle_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_objectData_2eproto;
};
// -------------------------------------------------------------------

class Proc_Brush final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Proc_Brush) */ {
 public:
  inline Proc_Brush() : Proc_Brush(nullptr) {}
  ~Proc_Brush() override;
  explicit PROTOBUF_CONSTEXPR Proc_Brush(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Proc_Brush(const Proc_Brush& from);
  Proc_Brush(Proc_Brush&& from) noexcept
    : Proc_Brush() {
    *this = ::std::move(from);
  }

  inline Proc_Brush& operator=(const Proc_Brush& from) {
    CopyFrom(from);
    return *this;
  }
  inline Proc_Brush& operator=(Proc_Brush&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Proc_Brush& default_instance() {
    return *internal_default_instance();
  }
  static inline const Proc_Brush* internal_default_instance() {
    return reinterpret_cast<const Proc_Brush*>(
               &_Proc_Brush_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Proc_Brush& a, Proc_Brush& b) {
    a.Swap(&b);
  }
  inline void Swap(Proc_Brush* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Proc_Brush* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Proc_Brush* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Proc_Brush>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Proc_Brush& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Proc_Brush& from) {
    Proc_Brush::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Proc_Brush* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Proc_Brush";
  }
  protected:
  explicit Proc_Brush(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextureNameFieldNumber = 1,
    kPosFieldNumber = 2,
    kDimFieldNumber = 3,
    kUvFieldNumber = 4,
    kDepthFieldNumber = 5,
  };
  // string textureName = 1;
  void clear_texturename();
  const std::string& texturename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_texturename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_texturename();
  PROTOBUF_NODISCARD std::string* release_texturename();
  void set_allocated_texturename(std::string* texturename);
  private:
  const std::string& _internal_texturename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_texturename(const std::string& value);
  std::string* _internal_mutable_texturename();
  public:

  // .Proc_Vec2 pos = 2;
  bool has_pos() const;
  private:
  bool _internal_has_pos() const;
  public:
  void clear_pos();
  const ::Proc_Vec2& pos() const;
  PROTOBUF_NODISCARD ::Proc_Vec2* release_pos();
  ::Proc_Vec2* mutable_pos();
  void set_allocated_pos(::Proc_Vec2* pos);
  private:
  const ::Proc_Vec2& _internal_pos() const;
  ::Proc_Vec2* _internal_mutable_pos();
  public:
  void unsafe_arena_set_allocated_pos(
      ::Proc_Vec2* pos);
  ::Proc_Vec2* unsafe_arena_release_pos();

  // .Proc_Vec2 dim = 3;
  bool has_dim() const;
  private:
  bool _internal_has_dim() const;
  public:
  void clear_dim();
  const ::Proc_Vec2& dim() const;
  PROTOBUF_NODISCARD ::Proc_Vec2* release_dim();
  ::Proc_Vec2* mutable_dim();
  void set_allocated_dim(::Proc_Vec2* dim);
  private:
  const ::Proc_Vec2& _internal_dim() const;
  ::Proc_Vec2* _internal_mutable_dim();
  public:
  void unsafe_arena_set_allocated_dim(
      ::Proc_Vec2* dim);
  ::Proc_Vec2* unsafe_arena_release_dim();

  // .Proc_Vec2 uv = 4;
  bool has_uv() const;
  private:
  bool _internal_has_uv() const;
  public:
  void clear_uv();
  const ::Proc_Vec2& uv() const;
  PROTOBUF_NODISCARD ::Proc_Vec2* release_uv();
  ::Proc_Vec2* mutable_uv();
  void set_allocated_uv(::Proc_Vec2* uv);
  private:
  const ::Proc_Vec2& _internal_uv() const;
  ::Proc_Vec2* _internal_mutable_uv();
  public:
  void unsafe_arena_set_allocated_uv(
      ::Proc_Vec2* uv);
  ::Proc_Vec2* unsafe_arena_release_uv();

  // float depth = 5;
  void clear_depth();
  float depth() const;
  void set_depth(float value);
  private:
  float _internal_depth() const;
  void _internal_set_depth(float value);
  public:

  // @@protoc_insertion_point(class_scope:Proc_Brush)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr texturename_;
    ::Proc_Vec2* pos_;
    ::Proc_Vec2* dim_;
    ::Proc_Vec2* uv_;
    float depth_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_objectData_2eproto;
};
// -------------------------------------------------------------------

class Proc_Layer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Proc_Layer) */ {
 public:
  inline Proc_Layer() : Proc_Layer(nullptr) {}
  ~Proc_Layer() override;
  explicit PROTOBUF_CONSTEXPR Proc_Layer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Proc_Layer(const Proc_Layer& from);
  Proc_Layer(Proc_Layer&& from) noexcept
    : Proc_Layer() {
    *this = ::std::move(from);
  }

  inline Proc_Layer& operator=(const Proc_Layer& from) {
    CopyFrom(from);
    return *this;
  }
  inline Proc_Layer& operator=(Proc_Layer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Proc_Layer& default_instance() {
    return *internal_default_instance();
  }
  static inline const Proc_Layer* internal_default_instance() {
    return reinterpret_cast<const Proc_Layer*>(
               &_Proc_Layer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Proc_Layer& a, Proc_Layer& b) {
    a.Swap(&b);
  }
  inline void Swap(Proc_Layer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Proc_Layer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Proc_Layer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Proc_Layer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Proc_Layer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Proc_Layer& from) {
    Proc_Layer::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Proc_Layer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Proc_Layer";
  }
  protected:
  explicit Proc_Layer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectListFieldNumber = 3,
    kBrushListFieldNumber = 4,
    kNameFieldNumber = 1,
    kDepthFieldNumber = 2,
  };
  // repeated .Proc_LoadObject objectList = 3;
  int objectlist_size() const;
  private:
  int _internal_objectlist_size() const;
  public:
  void clear_objectlist();
  ::Proc_LoadObject* mutable_objectlist(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Proc_LoadObject >*
      mutable_objectlist();
  private:
  const ::Proc_LoadObject& _internal_objectlist(int index) const;
  ::Proc_LoadObject* _internal_add_objectlist();
  public:
  const ::Proc_LoadObject& objectlist(int index) const;
  ::Proc_LoadObject* add_objectlist();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Proc_LoadObject >&
      objectlist() const;

  // repeated .Proc_Brush brushList = 4;
  int brushlist_size() const;
  private:
  int _internal_brushlist_size() const;
  public:
  void clear_brushlist();
  ::Proc_Brush* mutable_brushlist(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Proc_Brush >*
      mutable_brushlist();
  private:
  const ::Proc_Brush& _internal_brushlist(int index) const;
  ::Proc_Brush* _internal_add_brushlist();
  public:
  const ::Proc_Brush& brushlist(int index) const;
  ::Proc_Brush* add_brushlist();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Proc_Brush >&
      brushlist() const;

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // int32 depth = 2;
  void clear_depth();
  int32_t depth() const;
  void set_depth(int32_t value);
  private:
  int32_t _internal_depth() const;
  void _internal_set_depth(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Proc_Layer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Proc_LoadObject > objectlist_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Proc_Brush > brushlist_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    int32_t depth_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_objectData_2eproto;
};
// -------------------------------------------------------------------

class Proc_Scene final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Proc_Scene) */ {
 public:
  inline Proc_Scene() : Proc_Scene(nullptr) {}
  ~Proc_Scene() override;
  explicit PROTOBUF_CONSTEXPR Proc_Scene(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Proc_Scene(const Proc_Scene& from);
  Proc_Scene(Proc_Scene&& from) noexcept
    : Proc_Scene() {
    *this = ::std::move(from);
  }

  inline Proc_Scene& operator=(const Proc_Scene& from) {
    CopyFrom(from);
    return *this;
  }
  inline Proc_Scene& operator=(Proc_Scene&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Proc_Scene& default_instance() {
    return *internal_default_instance();
  }
  static inline const Proc_Scene* internal_default_instance() {
    return reinterpret_cast<const Proc_Scene*>(
               &_Proc_Scene_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Proc_Scene& a, Proc_Scene& b) {
    a.Swap(&b);
  }
  inline void Swap(Proc_Scene* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Proc_Scene* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Proc_Scene* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Proc_Scene>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Proc_Scene& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Proc_Scene& from) {
    Proc_Scene::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Proc_Scene* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Proc_Scene";
  }
  protected:
  explicit Proc_Scene(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLayerListFieldNumber = 2,
    kNameFieldNumber = 1,
  };
  // repeated .Proc_Layer layerList = 2;
  int layerlist_size() const;
  private:
  int _internal_layerlist_size() const;
  public:
  void clear_layerlist();
  ::Proc_Layer* mutable_layerlist(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Proc_Layer >*
      mutable_layerlist();
  private:
  const ::Proc_Layer& _internal_layerlist(int index) const;
  ::Proc_Layer* _internal_add_layerlist();
  public:
  const ::Proc_Layer& layerlist(int index) const;
  ::Proc_Layer* add_layerlist();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Proc_Layer >&
      layerlist() const;

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:Proc_Scene)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Proc_Layer > layerlist_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_objectData_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Proc_Vec2

// float valueX = 1;
inline void Proc_Vec2::clear_valuex() {
  _impl_.valuex_ = 0;
}
inline float Proc_Vec2::_internal_valuex() const {
  return _impl_.valuex_;
}
inline float Proc_Vec2::valuex() const {
  // @@protoc_insertion_point(field_get:Proc_Vec2.valueX)
  return _internal_valuex();
}
inline void Proc_Vec2::_internal_set_valuex(float value) {
  
  _impl_.valuex_ = value;
}
inline void Proc_Vec2::set_valuex(float value) {
  _internal_set_valuex(value);
  // @@protoc_insertion_point(field_set:Proc_Vec2.valueX)
}

// float valueY = 2;
inline void Proc_Vec2::clear_valuey() {
  _impl_.valuey_ = 0;
}
inline float Proc_Vec2::_internal_valuey() const {
  return _impl_.valuey_;
}
inline float Proc_Vec2::valuey() const {
  // @@protoc_insertion_point(field_get:Proc_Vec2.valueY)
  return _internal_valuey();
}
inline void Proc_Vec2::_internal_set_valuey(float value) {
  
  _impl_.valuey_ = value;
}
inline void Proc_Vec2::set_valuey(float value) {
  _internal_set_valuey(value);
  // @@protoc_insertion_point(field_set:Proc_Vec2.valueY)
}

// -------------------------------------------------------------------

// Proc_Vec3

// float valueX = 1;
inline void Proc_Vec3::clear_valuex() {
  _impl_.valuex_ = 0;
}
inline float Proc_Vec3::_internal_valuex() const {
  return _impl_.valuex_;
}
inline float Proc_Vec3::valuex() const {
  // @@protoc_insertion_point(field_get:Proc_Vec3.valueX)
  return _internal_valuex();
}
inline void Proc_Vec3::_internal_set_valuex(float value) {
  
  _impl_.valuex_ = value;
}
inline void Proc_Vec3::set_valuex(float value) {
  _internal_set_valuex(value);
  // @@protoc_insertion_point(field_set:Proc_Vec3.valueX)
}

// float valueY = 2;
inline void Proc_Vec3::clear_valuey() {
  _impl_.valuey_ = 0;
}
inline float Proc_Vec3::_internal_valuey() const {
  return _impl_.valuey_;
}
inline float Proc_Vec3::valuey() const {
  // @@protoc_insertion_point(field_get:Proc_Vec3.valueY)
  return _internal_valuey();
}
inline void Proc_Vec3::_internal_set_valuey(float value) {
  
  _impl_.valuey_ = value;
}
inline void Proc_Vec3::set_valuey(float value) {
  _internal_set_valuey(value);
  // @@protoc_insertion_point(field_set:Proc_Vec3.valueY)
}

// float valueZ = 3;
inline void Proc_Vec3::clear_valuez() {
  _impl_.valuez_ = 0;
}
inline float Proc_Vec3::_internal_valuez() const {
  return _impl_.valuez_;
}
inline float Proc_Vec3::valuez() const {
  // @@protoc_insertion_point(field_get:Proc_Vec3.valueZ)
  return _internal_valuez();
}
inline void Proc_Vec3::_internal_set_valuez(float value) {
  
  _impl_.valuez_ = value;
}
inline void Proc_Vec3::set_valuez(float value) {
  _internal_set_valuez(value);
  // @@protoc_insertion_point(field_set:Proc_Vec3.valueZ)
}

// -------------------------------------------------------------------

// Proc_Vec4

// float valueX = 1;
inline void Proc_Vec4::clear_valuex() {
  _impl_.valuex_ = 0;
}
inline float Proc_Vec4::_internal_valuex() const {
  return _impl_.valuex_;
}
inline float Proc_Vec4::valuex() const {
  // @@protoc_insertion_point(field_get:Proc_Vec4.valueX)
  return _internal_valuex();
}
inline void Proc_Vec4::_internal_set_valuex(float value) {
  
  _impl_.valuex_ = value;
}
inline void Proc_Vec4::set_valuex(float value) {
  _internal_set_valuex(value);
  // @@protoc_insertion_point(field_set:Proc_Vec4.valueX)
}

// float valueY = 2;
inline void Proc_Vec4::clear_valuey() {
  _impl_.valuey_ = 0;
}
inline float Proc_Vec4::_internal_valuey() const {
  return _impl_.valuey_;
}
inline float Proc_Vec4::valuey() const {
  // @@protoc_insertion_point(field_get:Proc_Vec4.valueY)
  return _internal_valuey();
}
inline void Proc_Vec4::_internal_set_valuey(float value) {
  
  _impl_.valuey_ = value;
}
inline void Proc_Vec4::set_valuey(float value) {
  _internal_set_valuey(value);
  // @@protoc_insertion_point(field_set:Proc_Vec4.valueY)
}

// float valueZ = 3;
inline void Proc_Vec4::clear_valuez() {
  _impl_.valuez_ = 0;
}
inline float Proc_Vec4::_internal_valuez() const {
  return _impl_.valuez_;
}
inline float Proc_Vec4::valuez() const {
  // @@protoc_insertion_point(field_get:Proc_Vec4.valueZ)
  return _internal_valuez();
}
inline void Proc_Vec4::_internal_set_valuez(float value) {
  
  _impl_.valuez_ = value;
}
inline void Proc_Vec4::set_valuez(float value) {
  _internal_set_valuez(value);
  // @@protoc_insertion_point(field_set:Proc_Vec4.valueZ)
}

// float valueW = 4;
inline void Proc_Vec4::clear_valuew() {
  _impl_.valuew_ = 0;
}
inline float Proc_Vec4::_internal_valuew() const {
  return _impl_.valuew_;
}
inline float Proc_Vec4::valuew() const {
  // @@protoc_insertion_point(field_get:Proc_Vec4.valueW)
  return _internal_valuew();
}
inline void Proc_Vec4::_internal_set_valuew(float value) {
  
  _impl_.valuew_ = value;
}
inline void Proc_Vec4::set_valuew(float value) {
  _internal_set_valuew(value);
  // @@protoc_insertion_point(field_set:Proc_Vec4.valueW)
}

// -------------------------------------------------------------------

// Proc_SpotLight

// .Proc_Vec2 pos = 1;
inline bool Proc_SpotLight::_internal_has_pos() const {
  return this != internal_default_instance() && _impl_.pos_ != nullptr;
}
inline bool Proc_SpotLight::has_pos() const {
  return _internal_has_pos();
}
inline void Proc_SpotLight::clear_pos() {
  if (GetArenaForAllocation() == nullptr && _impl_.pos_ != nullptr) {
    delete _impl_.pos_;
  }
  _impl_.pos_ = nullptr;
}
inline const ::Proc_Vec2& Proc_SpotLight::_internal_pos() const {
  const ::Proc_Vec2* p = _impl_.pos_;
  return p != nullptr ? *p : reinterpret_cast<const ::Proc_Vec2&>(
      ::_Proc_Vec2_default_instance_);
}
inline const ::Proc_Vec2& Proc_SpotLight::pos() const {
  // @@protoc_insertion_point(field_get:Proc_SpotLight.pos)
  return _internal_pos();
}
inline void Proc_SpotLight::unsafe_arena_set_allocated_pos(
    ::Proc_Vec2* pos) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pos_);
  }
  _impl_.pos_ = pos;
  if (pos) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Proc_SpotLight.pos)
}
inline ::Proc_Vec2* Proc_SpotLight::release_pos() {
  
  ::Proc_Vec2* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Proc_Vec2* Proc_SpotLight::unsafe_arena_release_pos() {
  // @@protoc_insertion_point(field_release:Proc_SpotLight.pos)
  
  ::Proc_Vec2* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
  return temp;
}
inline ::Proc_Vec2* Proc_SpotLight::_internal_mutable_pos() {
  
  if (_impl_.pos_ == nullptr) {
    auto* p = CreateMaybeMessage<::Proc_Vec2>(GetArenaForAllocation());
    _impl_.pos_ = p;
  }
  return _impl_.pos_;
}
inline ::Proc_Vec2* Proc_SpotLight::mutable_pos() {
  ::Proc_Vec2* _msg = _internal_mutable_pos();
  // @@protoc_insertion_point(field_mutable:Proc_SpotLight.pos)
  return _msg;
}
inline void Proc_SpotLight::set_allocated_pos(::Proc_Vec2* pos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.pos_;
  }
  if (pos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pos);
    if (message_arena != submessage_arena) {
      pos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pos, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.pos_ = pos;
  // @@protoc_insertion_point(field_set_allocated:Proc_SpotLight.pos)
}

// .Proc_Vec4 color = 2;
inline bool Proc_SpotLight::_internal_has_color() const {
  return this != internal_default_instance() && _impl_.color_ != nullptr;
}
inline bool Proc_SpotLight::has_color() const {
  return _internal_has_color();
}
inline void Proc_SpotLight::clear_color() {
  if (GetArenaForAllocation() == nullptr && _impl_.color_ != nullptr) {
    delete _impl_.color_;
  }
  _impl_.color_ = nullptr;
}
inline const ::Proc_Vec4& Proc_SpotLight::_internal_color() const {
  const ::Proc_Vec4* p = _impl_.color_;
  return p != nullptr ? *p : reinterpret_cast<const ::Proc_Vec4&>(
      ::_Proc_Vec4_default_instance_);
}
inline const ::Proc_Vec4& Proc_SpotLight::color() const {
  // @@protoc_insertion_point(field_get:Proc_SpotLight.color)
  return _internal_color();
}
inline void Proc_SpotLight::unsafe_arena_set_allocated_color(
    ::Proc_Vec4* color) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.color_);
  }
  _impl_.color_ = color;
  if (color) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Proc_SpotLight.color)
}
inline ::Proc_Vec4* Proc_SpotLight::release_color() {
  
  ::Proc_Vec4* temp = _impl_.color_;
  _impl_.color_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Proc_Vec4* Proc_SpotLight::unsafe_arena_release_color() {
  // @@protoc_insertion_point(field_release:Proc_SpotLight.color)
  
  ::Proc_Vec4* temp = _impl_.color_;
  _impl_.color_ = nullptr;
  return temp;
}
inline ::Proc_Vec4* Proc_SpotLight::_internal_mutable_color() {
  
  if (_impl_.color_ == nullptr) {
    auto* p = CreateMaybeMessage<::Proc_Vec4>(GetArenaForAllocation());
    _impl_.color_ = p;
  }
  return _impl_.color_;
}
inline ::Proc_Vec4* Proc_SpotLight::mutable_color() {
  ::Proc_Vec4* _msg = _internal_mutable_color();
  // @@protoc_insertion_point(field_mutable:Proc_SpotLight.color)
  return _msg;
}
inline void Proc_SpotLight::set_allocated_color(::Proc_Vec4* color) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.color_;
  }
  if (color) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(color);
    if (message_arena != submessage_arena) {
      color = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, color, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.color_ = color;
  // @@protoc_insertion_point(field_set_allocated:Proc_SpotLight.color)
}

// .Proc_Vec3 atenuation = 3;
inline bool Proc_SpotLight::_internal_has_atenuation() const {
  return this != internal_default_instance() && _impl_.atenuation_ != nullptr;
}
inline bool Proc_SpotLight::has_atenuation() const {
  return _internal_has_atenuation();
}
inline void Proc_SpotLight::clear_atenuation() {
  if (GetArenaForAllocation() == nullptr && _impl_.atenuation_ != nullptr) {
    delete _impl_.atenuation_;
  }
  _impl_.atenuation_ = nullptr;
}
inline const ::Proc_Vec3& Proc_SpotLight::_internal_atenuation() const {
  const ::Proc_Vec3* p = _impl_.atenuation_;
  return p != nullptr ? *p : reinterpret_cast<const ::Proc_Vec3&>(
      ::_Proc_Vec3_default_instance_);
}
inline const ::Proc_Vec3& Proc_SpotLight::atenuation() const {
  // @@protoc_insertion_point(field_get:Proc_SpotLight.atenuation)
  return _internal_atenuation();
}
inline void Proc_SpotLight::unsafe_arena_set_allocated_atenuation(
    ::Proc_Vec3* atenuation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.atenuation_);
  }
  _impl_.atenuation_ = atenuation;
  if (atenuation) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Proc_SpotLight.atenuation)
}
inline ::Proc_Vec3* Proc_SpotLight::release_atenuation() {
  
  ::Proc_Vec3* temp = _impl_.atenuation_;
  _impl_.atenuation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Proc_Vec3* Proc_SpotLight::unsafe_arena_release_atenuation() {
  // @@protoc_insertion_point(field_release:Proc_SpotLight.atenuation)
  
  ::Proc_Vec3* temp = _impl_.atenuation_;
  _impl_.atenuation_ = nullptr;
  return temp;
}
inline ::Proc_Vec3* Proc_SpotLight::_internal_mutable_atenuation() {
  
  if (_impl_.atenuation_ == nullptr) {
    auto* p = CreateMaybeMessage<::Proc_Vec3>(GetArenaForAllocation());
    _impl_.atenuation_ = p;
  }
  return _impl_.atenuation_;
}
inline ::Proc_Vec3* Proc_SpotLight::mutable_atenuation() {
  ::Proc_Vec3* _msg = _internal_mutable_atenuation();
  // @@protoc_insertion_point(field_mutable:Proc_SpotLight.atenuation)
  return _msg;
}
inline void Proc_SpotLight::set_allocated_atenuation(::Proc_Vec3* atenuation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.atenuation_;
  }
  if (atenuation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(atenuation);
    if (message_arena != submessage_arena) {
      atenuation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, atenuation, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.atenuation_ = atenuation;
  // @@protoc_insertion_point(field_set_allocated:Proc_SpotLight.atenuation)
}

// -------------------------------------------------------------------

// Proc_ColiderBox

// .Proc_Vec2 pos = 1;
inline bool Proc_ColiderBox::_internal_has_pos() const {
  return this != internal_default_instance() && _impl_.pos_ != nullptr;
}
inline bool Proc_ColiderBox::has_pos() const {
  return _internal_has_pos();
}
inline void Proc_ColiderBox::clear_pos() {
  if (GetArenaForAllocation() == nullptr && _impl_.pos_ != nullptr) {
    delete _impl_.pos_;
  }
  _impl_.pos_ = nullptr;
}
inline const ::Proc_Vec2& Proc_ColiderBox::_internal_pos() const {
  const ::Proc_Vec2* p = _impl_.pos_;
  return p != nullptr ? *p : reinterpret_cast<const ::Proc_Vec2&>(
      ::_Proc_Vec2_default_instance_);
}
inline const ::Proc_Vec2& Proc_ColiderBox::pos() const {
  // @@protoc_insertion_point(field_get:Proc_ColiderBox.pos)
  return _internal_pos();
}
inline void Proc_ColiderBox::unsafe_arena_set_allocated_pos(
    ::Proc_Vec2* pos) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pos_);
  }
  _impl_.pos_ = pos;
  if (pos) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Proc_ColiderBox.pos)
}
inline ::Proc_Vec2* Proc_ColiderBox::release_pos() {
  
  ::Proc_Vec2* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Proc_Vec2* Proc_ColiderBox::unsafe_arena_release_pos() {
  // @@protoc_insertion_point(field_release:Proc_ColiderBox.pos)
  
  ::Proc_Vec2* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
  return temp;
}
inline ::Proc_Vec2* Proc_ColiderBox::_internal_mutable_pos() {
  
  if (_impl_.pos_ == nullptr) {
    auto* p = CreateMaybeMessage<::Proc_Vec2>(GetArenaForAllocation());
    _impl_.pos_ = p;
  }
  return _impl_.pos_;
}
inline ::Proc_Vec2* Proc_ColiderBox::mutable_pos() {
  ::Proc_Vec2* _msg = _internal_mutable_pos();
  // @@protoc_insertion_point(field_mutable:Proc_ColiderBox.pos)
  return _msg;
}
inline void Proc_ColiderBox::set_allocated_pos(::Proc_Vec2* pos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.pos_;
  }
  if (pos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pos);
    if (message_arena != submessage_arena) {
      pos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pos, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.pos_ = pos;
  // @@protoc_insertion_point(field_set_allocated:Proc_ColiderBox.pos)
}

// .Proc_Vec2 dim = 2;
inline bool Proc_ColiderBox::_internal_has_dim() const {
  return this != internal_default_instance() && _impl_.dim_ != nullptr;
}
inline bool Proc_ColiderBox::has_dim() const {
  return _internal_has_dim();
}
inline void Proc_ColiderBox::clear_dim() {
  if (GetArenaForAllocation() == nullptr && _impl_.dim_ != nullptr) {
    delete _impl_.dim_;
  }
  _impl_.dim_ = nullptr;
}
inline const ::Proc_Vec2& Proc_ColiderBox::_internal_dim() const {
  const ::Proc_Vec2* p = _impl_.dim_;
  return p != nullptr ? *p : reinterpret_cast<const ::Proc_Vec2&>(
      ::_Proc_Vec2_default_instance_);
}
inline const ::Proc_Vec2& Proc_ColiderBox::dim() const {
  // @@protoc_insertion_point(field_get:Proc_ColiderBox.dim)
  return _internal_dim();
}
inline void Proc_ColiderBox::unsafe_arena_set_allocated_dim(
    ::Proc_Vec2* dim) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.dim_);
  }
  _impl_.dim_ = dim;
  if (dim) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Proc_ColiderBox.dim)
}
inline ::Proc_Vec2* Proc_ColiderBox::release_dim() {
  
  ::Proc_Vec2* temp = _impl_.dim_;
  _impl_.dim_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Proc_Vec2* Proc_ColiderBox::unsafe_arena_release_dim() {
  // @@protoc_insertion_point(field_release:Proc_ColiderBox.dim)
  
  ::Proc_Vec2* temp = _impl_.dim_;
  _impl_.dim_ = nullptr;
  return temp;
}
inline ::Proc_Vec2* Proc_ColiderBox::_internal_mutable_dim() {
  
  if (_impl_.dim_ == nullptr) {
    auto* p = CreateMaybeMessage<::Proc_Vec2>(GetArenaForAllocation());
    _impl_.dim_ = p;
  }
  return _impl_.dim_;
}
inline ::Proc_Vec2* Proc_ColiderBox::mutable_dim() {
  ::Proc_Vec2* _msg = _internal_mutable_dim();
  // @@protoc_insertion_point(field_mutable:Proc_ColiderBox.dim)
  return _msg;
}
inline void Proc_ColiderBox::set_allocated_dim(::Proc_Vec2* dim) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.dim_;
  }
  if (dim) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(dim);
    if (message_arena != submessage_arena) {
      dim = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dim, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.dim_ = dim;
  // @@protoc_insertion_point(field_set_allocated:Proc_ColiderBox.dim)
}

// -------------------------------------------------------------------

// Proc_Sprite

// string texturePath = 1;
inline void Proc_Sprite::clear_texturepath() {
  _impl_.texturepath_.ClearToEmpty();
}
inline const std::string& Proc_Sprite::texturepath() const {
  // @@protoc_insertion_point(field_get:Proc_Sprite.texturePath)
  return _internal_texturepath();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Proc_Sprite::set_texturepath(ArgT0&& arg0, ArgT... args) {
 
 _impl_.texturepath_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Proc_Sprite.texturePath)
}
inline std::string* Proc_Sprite::mutable_texturepath() {
  std::string* _s = _internal_mutable_texturepath();
  // @@protoc_insertion_point(field_mutable:Proc_Sprite.texturePath)
  return _s;
}
inline const std::string& Proc_Sprite::_internal_texturepath() const {
  return _impl_.texturepath_.Get();
}
inline void Proc_Sprite::_internal_set_texturepath(const std::string& value) {
  
  _impl_.texturepath_.Set(value, GetArenaForAllocation());
}
inline std::string* Proc_Sprite::_internal_mutable_texturepath() {
  
  return _impl_.texturepath_.Mutable(GetArenaForAllocation());
}
inline std::string* Proc_Sprite::release_texturepath() {
  // @@protoc_insertion_point(field_release:Proc_Sprite.texturePath)
  return _impl_.texturepath_.Release();
}
inline void Proc_Sprite::set_allocated_texturepath(std::string* texturepath) {
  if (texturepath != nullptr) {
    
  } else {
    
  }
  _impl_.texturepath_.SetAllocated(texturepath, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.texturepath_.IsDefault()) {
    _impl_.texturepath_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Proc_Sprite.texturePath)
}

// .Proc_Vec2 dim = 2;
inline bool Proc_Sprite::_internal_has_dim() const {
  return this != internal_default_instance() && _impl_.dim_ != nullptr;
}
inline bool Proc_Sprite::has_dim() const {
  return _internal_has_dim();
}
inline void Proc_Sprite::clear_dim() {
  if (GetArenaForAllocation() == nullptr && _impl_.dim_ != nullptr) {
    delete _impl_.dim_;
  }
  _impl_.dim_ = nullptr;
}
inline const ::Proc_Vec2& Proc_Sprite::_internal_dim() const {
  const ::Proc_Vec2* p = _impl_.dim_;
  return p != nullptr ? *p : reinterpret_cast<const ::Proc_Vec2&>(
      ::_Proc_Vec2_default_instance_);
}
inline const ::Proc_Vec2& Proc_Sprite::dim() const {
  // @@protoc_insertion_point(field_get:Proc_Sprite.dim)
  return _internal_dim();
}
inline void Proc_Sprite::unsafe_arena_set_allocated_dim(
    ::Proc_Vec2* dim) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.dim_);
  }
  _impl_.dim_ = dim;
  if (dim) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Proc_Sprite.dim)
}
inline ::Proc_Vec2* Proc_Sprite::release_dim() {
  
  ::Proc_Vec2* temp = _impl_.dim_;
  _impl_.dim_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Proc_Vec2* Proc_Sprite::unsafe_arena_release_dim() {
  // @@protoc_insertion_point(field_release:Proc_Sprite.dim)
  
  ::Proc_Vec2* temp = _impl_.dim_;
  _impl_.dim_ = nullptr;
  return temp;
}
inline ::Proc_Vec2* Proc_Sprite::_internal_mutable_dim() {
  
  if (_impl_.dim_ == nullptr) {
    auto* p = CreateMaybeMessage<::Proc_Vec2>(GetArenaForAllocation());
    _impl_.dim_ = p;
  }
  return _impl_.dim_;
}
inline ::Proc_Vec2* Proc_Sprite::mutable_dim() {
  ::Proc_Vec2* _msg = _internal_mutable_dim();
  // @@protoc_insertion_point(field_mutable:Proc_Sprite.dim)
  return _msg;
}
inline void Proc_Sprite::set_allocated_dim(::Proc_Vec2* dim) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.dim_;
  }
  if (dim) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(dim);
    if (message_arena != submessage_arena) {
      dim = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dim, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.dim_ = dim;
  // @@protoc_insertion_point(field_set_allocated:Proc_Sprite.dim)
}

// string name = 3;
inline void Proc_Sprite::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Proc_Sprite::name() const {
  // @@protoc_insertion_point(field_get:Proc_Sprite.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Proc_Sprite::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Proc_Sprite.name)
}
inline std::string* Proc_Sprite::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:Proc_Sprite.name)
  return _s;
}
inline const std::string& Proc_Sprite::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Proc_Sprite::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Proc_Sprite::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Proc_Sprite::release_name() {
  // @@protoc_insertion_point(field_release:Proc_Sprite.name)
  return _impl_.name_.Release();
}
inline void Proc_Sprite::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Proc_Sprite.name)
}

// string packetName = 4;
inline void Proc_Sprite::clear_packetname() {
  _impl_.packetname_.ClearToEmpty();
}
inline const std::string& Proc_Sprite::packetname() const {
  // @@protoc_insertion_point(field_get:Proc_Sprite.packetName)
  return _internal_packetname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Proc_Sprite::set_packetname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.packetname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Proc_Sprite.packetName)
}
inline std::string* Proc_Sprite::mutable_packetname() {
  std::string* _s = _internal_mutable_packetname();
  // @@protoc_insertion_point(field_mutable:Proc_Sprite.packetName)
  return _s;
}
inline const std::string& Proc_Sprite::_internal_packetname() const {
  return _impl_.packetname_.Get();
}
inline void Proc_Sprite::_internal_set_packetname(const std::string& value) {
  
  _impl_.packetname_.Set(value, GetArenaForAllocation());
}
inline std::string* Proc_Sprite::_internal_mutable_packetname() {
  
  return _impl_.packetname_.Mutable(GetArenaForAllocation());
}
inline std::string* Proc_Sprite::release_packetname() {
  // @@protoc_insertion_point(field_release:Proc_Sprite.packetName)
  return _impl_.packetname_.Release();
}
inline void Proc_Sprite::set_allocated_packetname(std::string* packetname) {
  if (packetname != nullptr) {
    
  } else {
    
  }
  _impl_.packetname_.SetAllocated(packetname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.packetname_.IsDefault()) {
    _impl_.packetname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Proc_Sprite.packetName)
}

// bool isInvert = 5;
inline void Proc_Sprite::clear_isinvert() {
  _impl_.isinvert_ = false;
}
inline bool Proc_Sprite::_internal_isinvert() const {
  return _impl_.isinvert_;
}
inline bool Proc_Sprite::isinvert() const {
  // @@protoc_insertion_point(field_get:Proc_Sprite.isInvert)
  return _internal_isinvert();
}
inline void Proc_Sprite::_internal_set_isinvert(bool value) {
  
  _impl_.isinvert_ = value;
}
inline void Proc_Sprite::set_isinvert(bool value) {
  _internal_set_isinvert(value);
  // @@protoc_insertion_point(field_set:Proc_Sprite.isInvert)
}

// -------------------------------------------------------------------

// Proc_OwnSprite

// .Proc_Sprite Proc_Sprite = 1;
inline bool Proc_OwnSprite::_internal_has_proc_sprite() const {
  return this != internal_default_instance() && _impl_.proc_sprite_ != nullptr;
}
inline bool Proc_OwnSprite::has_proc_sprite() const {
  return _internal_has_proc_sprite();
}
inline void Proc_OwnSprite::clear_proc_sprite() {
  if (GetArenaForAllocation() == nullptr && _impl_.proc_sprite_ != nullptr) {
    delete _impl_.proc_sprite_;
  }
  _impl_.proc_sprite_ = nullptr;
}
inline const ::Proc_Sprite& Proc_OwnSprite::_internal_proc_sprite() const {
  const ::Proc_Sprite* p = _impl_.proc_sprite_;
  return p != nullptr ? *p : reinterpret_cast<const ::Proc_Sprite&>(
      ::_Proc_Sprite_default_instance_);
}
inline const ::Proc_Sprite& Proc_OwnSprite::proc_sprite() const {
  // @@protoc_insertion_point(field_get:Proc_OwnSprite.Proc_Sprite)
  return _internal_proc_sprite();
}
inline void Proc_OwnSprite::unsafe_arena_set_allocated_proc_sprite(
    ::Proc_Sprite* proc_sprite) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.proc_sprite_);
  }
  _impl_.proc_sprite_ = proc_sprite;
  if (proc_sprite) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Proc_OwnSprite.Proc_Sprite)
}
inline ::Proc_Sprite* Proc_OwnSprite::release_proc_sprite() {
  
  ::Proc_Sprite* temp = _impl_.proc_sprite_;
  _impl_.proc_sprite_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Proc_Sprite* Proc_OwnSprite::unsafe_arena_release_proc_sprite() {
  // @@protoc_insertion_point(field_release:Proc_OwnSprite.Proc_Sprite)
  
  ::Proc_Sprite* temp = _impl_.proc_sprite_;
  _impl_.proc_sprite_ = nullptr;
  return temp;
}
inline ::Proc_Sprite* Proc_OwnSprite::_internal_mutable_proc_sprite() {
  
  if (_impl_.proc_sprite_ == nullptr) {
    auto* p = CreateMaybeMessage<::Proc_Sprite>(GetArenaForAllocation());
    _impl_.proc_sprite_ = p;
  }
  return _impl_.proc_sprite_;
}
inline ::Proc_Sprite* Proc_OwnSprite::mutable_proc_sprite() {
  ::Proc_Sprite* _msg = _internal_mutable_proc_sprite();
  // @@protoc_insertion_point(field_mutable:Proc_OwnSprite.Proc_Sprite)
  return _msg;
}
inline void Proc_OwnSprite::set_allocated_proc_sprite(::Proc_Sprite* proc_sprite) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.proc_sprite_;
  }
  if (proc_sprite) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(proc_sprite);
    if (message_arena != submessage_arena) {
      proc_sprite = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, proc_sprite, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.proc_sprite_ = proc_sprite;
  // @@protoc_insertion_point(field_set_allocated:Proc_OwnSprite.Proc_Sprite)
}

// .Proc_Vec2 offsetPos = 2;
inline bool Proc_OwnSprite::_internal_has_offsetpos() const {
  return this != internal_default_instance() && _impl_.offsetpos_ != nullptr;
}
inline bool Proc_OwnSprite::has_offsetpos() const {
  return _internal_has_offsetpos();
}
inline void Proc_OwnSprite::clear_offsetpos() {
  if (GetArenaForAllocation() == nullptr && _impl_.offsetpos_ != nullptr) {
    delete _impl_.offsetpos_;
  }
  _impl_.offsetpos_ = nullptr;
}
inline const ::Proc_Vec2& Proc_OwnSprite::_internal_offsetpos() const {
  const ::Proc_Vec2* p = _impl_.offsetpos_;
  return p != nullptr ? *p : reinterpret_cast<const ::Proc_Vec2&>(
      ::_Proc_Vec2_default_instance_);
}
inline const ::Proc_Vec2& Proc_OwnSprite::offsetpos() const {
  // @@protoc_insertion_point(field_get:Proc_OwnSprite.offsetPos)
  return _internal_offsetpos();
}
inline void Proc_OwnSprite::unsafe_arena_set_allocated_offsetpos(
    ::Proc_Vec2* offsetpos) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.offsetpos_);
  }
  _impl_.offsetpos_ = offsetpos;
  if (offsetpos) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Proc_OwnSprite.offsetPos)
}
inline ::Proc_Vec2* Proc_OwnSprite::release_offsetpos() {
  
  ::Proc_Vec2* temp = _impl_.offsetpos_;
  _impl_.offsetpos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Proc_Vec2* Proc_OwnSprite::unsafe_arena_release_offsetpos() {
  // @@protoc_insertion_point(field_release:Proc_OwnSprite.offsetPos)
  
  ::Proc_Vec2* temp = _impl_.offsetpos_;
  _impl_.offsetpos_ = nullptr;
  return temp;
}
inline ::Proc_Vec2* Proc_OwnSprite::_internal_mutable_offsetpos() {
  
  if (_impl_.offsetpos_ == nullptr) {
    auto* p = CreateMaybeMessage<::Proc_Vec2>(GetArenaForAllocation());
    _impl_.offsetpos_ = p;
  }
  return _impl_.offsetpos_;
}
inline ::Proc_Vec2* Proc_OwnSprite::mutable_offsetpos() {
  ::Proc_Vec2* _msg = _internal_mutable_offsetpos();
  // @@protoc_insertion_point(field_mutable:Proc_OwnSprite.offsetPos)
  return _msg;
}
inline void Proc_OwnSprite::set_allocated_offsetpos(::Proc_Vec2* offsetpos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.offsetpos_;
  }
  if (offsetpos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(offsetpos);
    if (message_arena != submessage_arena) {
      offsetpos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, offsetpos, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.offsetpos_ = offsetpos;
  // @@protoc_insertion_point(field_set_allocated:Proc_OwnSprite.offsetPos)
}

// .Proc_Vec2 offsetScale = 3;
inline bool Proc_OwnSprite::_internal_has_offsetscale() const {
  return this != internal_default_instance() && _impl_.offsetscale_ != nullptr;
}
inline bool Proc_OwnSprite::has_offsetscale() const {
  return _internal_has_offsetscale();
}
inline void Proc_OwnSprite::clear_offsetscale() {
  if (GetArenaForAllocation() == nullptr && _impl_.offsetscale_ != nullptr) {
    delete _impl_.offsetscale_;
  }
  _impl_.offsetscale_ = nullptr;
}
inline const ::Proc_Vec2& Proc_OwnSprite::_internal_offsetscale() const {
  const ::Proc_Vec2* p = _impl_.offsetscale_;
  return p != nullptr ? *p : reinterpret_cast<const ::Proc_Vec2&>(
      ::_Proc_Vec2_default_instance_);
}
inline const ::Proc_Vec2& Proc_OwnSprite::offsetscale() const {
  // @@protoc_insertion_point(field_get:Proc_OwnSprite.offsetScale)
  return _internal_offsetscale();
}
inline void Proc_OwnSprite::unsafe_arena_set_allocated_offsetscale(
    ::Proc_Vec2* offsetscale) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.offsetscale_);
  }
  _impl_.offsetscale_ = offsetscale;
  if (offsetscale) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Proc_OwnSprite.offsetScale)
}
inline ::Proc_Vec2* Proc_OwnSprite::release_offsetscale() {
  
  ::Proc_Vec2* temp = _impl_.offsetscale_;
  _impl_.offsetscale_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Proc_Vec2* Proc_OwnSprite::unsafe_arena_release_offsetscale() {
  // @@protoc_insertion_point(field_release:Proc_OwnSprite.offsetScale)
  
  ::Proc_Vec2* temp = _impl_.offsetscale_;
  _impl_.offsetscale_ = nullptr;
  return temp;
}
inline ::Proc_Vec2* Proc_OwnSprite::_internal_mutable_offsetscale() {
  
  if (_impl_.offsetscale_ == nullptr) {
    auto* p = CreateMaybeMessage<::Proc_Vec2>(GetArenaForAllocation());
    _impl_.offsetscale_ = p;
  }
  return _impl_.offsetscale_;
}
inline ::Proc_Vec2* Proc_OwnSprite::mutable_offsetscale() {
  ::Proc_Vec2* _msg = _internal_mutable_offsetscale();
  // @@protoc_insertion_point(field_mutable:Proc_OwnSprite.offsetScale)
  return _msg;
}
inline void Proc_OwnSprite::set_allocated_offsetscale(::Proc_Vec2* offsetscale) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.offsetscale_;
  }
  if (offsetscale) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(offsetscale);
    if (message_arena != submessage_arena) {
      offsetscale = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, offsetscale, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.offsetscale_ = offsetscale;
  // @@protoc_insertion_point(field_set_allocated:Proc_OwnSprite.offsetScale)
}

// .Proc_Vec4 color = 4;
inline bool Proc_OwnSprite::_internal_has_color() const {
  return this != internal_default_instance() && _impl_.color_ != nullptr;
}
inline bool Proc_OwnSprite::has_color() const {
  return _internal_has_color();
}
inline void Proc_OwnSprite::clear_color() {
  if (GetArenaForAllocation() == nullptr && _impl_.color_ != nullptr) {
    delete _impl_.color_;
  }
  _impl_.color_ = nullptr;
}
inline const ::Proc_Vec4& Proc_OwnSprite::_internal_color() const {
  const ::Proc_Vec4* p = _impl_.color_;
  return p != nullptr ? *p : reinterpret_cast<const ::Proc_Vec4&>(
      ::_Proc_Vec4_default_instance_);
}
inline const ::Proc_Vec4& Proc_OwnSprite::color() const {
  // @@protoc_insertion_point(field_get:Proc_OwnSprite.color)
  return _internal_color();
}
inline void Proc_OwnSprite::unsafe_arena_set_allocated_color(
    ::Proc_Vec4* color) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.color_);
  }
  _impl_.color_ = color;
  if (color) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Proc_OwnSprite.color)
}
inline ::Proc_Vec4* Proc_OwnSprite::release_color() {
  
  ::Proc_Vec4* temp = _impl_.color_;
  _impl_.color_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Proc_Vec4* Proc_OwnSprite::unsafe_arena_release_color() {
  // @@protoc_insertion_point(field_release:Proc_OwnSprite.color)
  
  ::Proc_Vec4* temp = _impl_.color_;
  _impl_.color_ = nullptr;
  return temp;
}
inline ::Proc_Vec4* Proc_OwnSprite::_internal_mutable_color() {
  
  if (_impl_.color_ == nullptr) {
    auto* p = CreateMaybeMessage<::Proc_Vec4>(GetArenaForAllocation());
    _impl_.color_ = p;
  }
  return _impl_.color_;
}
inline ::Proc_Vec4* Proc_OwnSprite::mutable_color() {
  ::Proc_Vec4* _msg = _internal_mutable_color();
  // @@protoc_insertion_point(field_mutable:Proc_OwnSprite.color)
  return _msg;
}
inline void Proc_OwnSprite::set_allocated_color(::Proc_Vec4* color) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.color_;
  }
  if (color) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(color);
    if (message_arena != submessage_arena) {
      color = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, color, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.color_ = color;
  // @@protoc_insertion_point(field_set_allocated:Proc_OwnSprite.color)
}

// float depth = 5;
inline void Proc_OwnSprite::clear_depth() {
  _impl_.depth_ = 0;
}
inline float Proc_OwnSprite::_internal_depth() const {
  return _impl_.depth_;
}
inline float Proc_OwnSprite::depth() const {
  // @@protoc_insertion_point(field_get:Proc_OwnSprite.depth)
  return _internal_depth();
}
inline void Proc_OwnSprite::_internal_set_depth(float value) {
  
  _impl_.depth_ = value;
}
inline void Proc_OwnSprite::set_depth(float value) {
  _internal_set_depth(value);
  // @@protoc_insertion_point(field_set:Proc_OwnSprite.depth)
}

// optional float angle = 6;
inline bool Proc_OwnSprite::_internal_has_angle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Proc_OwnSprite::has_angle() const {
  return _internal_has_angle();
}
inline void Proc_OwnSprite::clear_angle() {
  _impl_.angle_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline float Proc_OwnSprite::_internal_angle() const {
  return _impl_.angle_;
}
inline float Proc_OwnSprite::angle() const {
  // @@protoc_insertion_point(field_get:Proc_OwnSprite.angle)
  return _internal_angle();
}
inline void Proc_OwnSprite::_internal_set_angle(float value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.angle_ = value;
}
inline void Proc_OwnSprite::set_angle(float value) {
  _internal_set_angle(value);
  // @@protoc_insertion_point(field_set:Proc_OwnSprite.angle)
}

// -------------------------------------------------------------------

// Proc_Object

// string name = 1;
inline void Proc_Object::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Proc_Object::name() const {
  // @@protoc_insertion_point(field_get:Proc_Object.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Proc_Object::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Proc_Object.name)
}
inline std::string* Proc_Object::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:Proc_Object.name)
  return _s;
}
inline const std::string& Proc_Object::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Proc_Object::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Proc_Object::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Proc_Object::release_name() {
  // @@protoc_insertion_point(field_release:Proc_Object.name)
  return _impl_.name_.Release();
}
inline void Proc_Object::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Proc_Object.name)
}

// repeated .Proc_OwnSprite Proc_SpriteList = 2;
inline int Proc_Object::_internal_proc_spritelist_size() const {
  return _impl_.proc_spritelist_.size();
}
inline int Proc_Object::proc_spritelist_size() const {
  return _internal_proc_spritelist_size();
}
inline void Proc_Object::clear_proc_spritelist() {
  _impl_.proc_spritelist_.Clear();
}
inline ::Proc_OwnSprite* Proc_Object::mutable_proc_spritelist(int index) {
  // @@protoc_insertion_point(field_mutable:Proc_Object.Proc_SpriteList)
  return _impl_.proc_spritelist_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Proc_OwnSprite >*
Proc_Object::mutable_proc_spritelist() {
  // @@protoc_insertion_point(field_mutable_list:Proc_Object.Proc_SpriteList)
  return &_impl_.proc_spritelist_;
}
inline const ::Proc_OwnSprite& Proc_Object::_internal_proc_spritelist(int index) const {
  return _impl_.proc_spritelist_.Get(index);
}
inline const ::Proc_OwnSprite& Proc_Object::proc_spritelist(int index) const {
  // @@protoc_insertion_point(field_get:Proc_Object.Proc_SpriteList)
  return _internal_proc_spritelist(index);
}
inline ::Proc_OwnSprite* Proc_Object::_internal_add_proc_spritelist() {
  return _impl_.proc_spritelist_.Add();
}
inline ::Proc_OwnSprite* Proc_Object::add_proc_spritelist() {
  ::Proc_OwnSprite* _add = _internal_add_proc_spritelist();
  // @@protoc_insertion_point(field_add:Proc_Object.Proc_SpriteList)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Proc_OwnSprite >&
Proc_Object::proc_spritelist() const {
  // @@protoc_insertion_point(field_list:Proc_Object.Proc_SpriteList)
  return _impl_.proc_spritelist_;
}

// repeated .Proc_SpotLight lightList = 3;
inline int Proc_Object::_internal_lightlist_size() const {
  return _impl_.lightlist_.size();
}
inline int Proc_Object::lightlist_size() const {
  return _internal_lightlist_size();
}
inline void Proc_Object::clear_lightlist() {
  _impl_.lightlist_.Clear();
}
inline ::Proc_SpotLight* Proc_Object::mutable_lightlist(int index) {
  // @@protoc_insertion_point(field_mutable:Proc_Object.lightList)
  return _impl_.lightlist_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Proc_SpotLight >*
Proc_Object::mutable_lightlist() {
  // @@protoc_insertion_point(field_mutable_list:Proc_Object.lightList)
  return &_impl_.lightlist_;
}
inline const ::Proc_SpotLight& Proc_Object::_internal_lightlist(int index) const {
  return _impl_.lightlist_.Get(index);
}
inline const ::Proc_SpotLight& Proc_Object::lightlist(int index) const {
  // @@protoc_insertion_point(field_get:Proc_Object.lightList)
  return _internal_lightlist(index);
}
inline ::Proc_SpotLight* Proc_Object::_internal_add_lightlist() {
  return _impl_.lightlist_.Add();
}
inline ::Proc_SpotLight* Proc_Object::add_lightlist() {
  ::Proc_SpotLight* _add = _internal_add_lightlist();
  // @@protoc_insertion_point(field_add:Proc_Object.lightList)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Proc_SpotLight >&
Proc_Object::lightlist() const {
  // @@protoc_insertion_point(field_list:Proc_Object.lightList)
  return _impl_.lightlist_;
}

// repeated .Proc_ColiderBox coliderList = 4;
inline int Proc_Object::_internal_coliderlist_size() const {
  return _impl_.coliderlist_.size();
}
inline int Proc_Object::coliderlist_size() const {
  return _internal_coliderlist_size();
}
inline void Proc_Object::clear_coliderlist() {
  _impl_.coliderlist_.Clear();
}
inline ::Proc_ColiderBox* Proc_Object::mutable_coliderlist(int index) {
  // @@protoc_insertion_point(field_mutable:Proc_Object.coliderList)
  return _impl_.coliderlist_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Proc_ColiderBox >*
Proc_Object::mutable_coliderlist() {
  // @@protoc_insertion_point(field_mutable_list:Proc_Object.coliderList)
  return &_impl_.coliderlist_;
}
inline const ::Proc_ColiderBox& Proc_Object::_internal_coliderlist(int index) const {
  return _impl_.coliderlist_.Get(index);
}
inline const ::Proc_ColiderBox& Proc_Object::coliderlist(int index) const {
  // @@protoc_insertion_point(field_get:Proc_Object.coliderList)
  return _internal_coliderlist(index);
}
inline ::Proc_ColiderBox* Proc_Object::_internal_add_coliderlist() {
  return _impl_.coliderlist_.Add();
}
inline ::Proc_ColiderBox* Proc_Object::add_coliderlist() {
  ::Proc_ColiderBox* _add = _internal_add_coliderlist();
  // @@protoc_insertion_point(field_add:Proc_Object.coliderList)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Proc_ColiderBox >&
Proc_Object::coliderlist() const {
  // @@protoc_insertion_point(field_list:Proc_Object.coliderList)
  return _impl_.coliderlist_;
}

// -------------------------------------------------------------------

// Proc_LoadObject

// .Proc_Object refab = 1;
inline bool Proc_LoadObject::_internal_has_refab() const {
  return this != internal_default_instance() && _impl_.refab_ != nullptr;
}
inline bool Proc_LoadObject::has_refab() const {
  return _internal_has_refab();
}
inline void Proc_LoadObject::clear_refab() {
  if (GetArenaForAllocation() == nullptr && _impl_.refab_ != nullptr) {
    delete _impl_.refab_;
  }
  _impl_.refab_ = nullptr;
}
inline const ::Proc_Object& Proc_LoadObject::_internal_refab() const {
  const ::Proc_Object* p = _impl_.refab_;
  return p != nullptr ? *p : reinterpret_cast<const ::Proc_Object&>(
      ::_Proc_Object_default_instance_);
}
inline const ::Proc_Object& Proc_LoadObject::refab() const {
  // @@protoc_insertion_point(field_get:Proc_LoadObject.refab)
  return _internal_refab();
}
inline void Proc_LoadObject::unsafe_arena_set_allocated_refab(
    ::Proc_Object* refab) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.refab_);
  }
  _impl_.refab_ = refab;
  if (refab) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Proc_LoadObject.refab)
}
inline ::Proc_Object* Proc_LoadObject::release_refab() {
  
  ::Proc_Object* temp = _impl_.refab_;
  _impl_.refab_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Proc_Object* Proc_LoadObject::unsafe_arena_release_refab() {
  // @@protoc_insertion_point(field_release:Proc_LoadObject.refab)
  
  ::Proc_Object* temp = _impl_.refab_;
  _impl_.refab_ = nullptr;
  return temp;
}
inline ::Proc_Object* Proc_LoadObject::_internal_mutable_refab() {
  
  if (_impl_.refab_ == nullptr) {
    auto* p = CreateMaybeMessage<::Proc_Object>(GetArenaForAllocation());
    _impl_.refab_ = p;
  }
  return _impl_.refab_;
}
inline ::Proc_Object* Proc_LoadObject::mutable_refab() {
  ::Proc_Object* _msg = _internal_mutable_refab();
  // @@protoc_insertion_point(field_mutable:Proc_LoadObject.refab)
  return _msg;
}
inline void Proc_LoadObject::set_allocated_refab(::Proc_Object* refab) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.refab_;
  }
  if (refab) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(refab);
    if (message_arena != submessage_arena) {
      refab = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, refab, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.refab_ = refab;
  // @@protoc_insertion_point(field_set_allocated:Proc_LoadObject.refab)
}

// .Proc_Vec2 pos = 2;
inline bool Proc_LoadObject::_internal_has_pos() const {
  return this != internal_default_instance() && _impl_.pos_ != nullptr;
}
inline bool Proc_LoadObject::has_pos() const {
  return _internal_has_pos();
}
inline void Proc_LoadObject::clear_pos() {
  if (GetArenaForAllocation() == nullptr && _impl_.pos_ != nullptr) {
    delete _impl_.pos_;
  }
  _impl_.pos_ = nullptr;
}
inline const ::Proc_Vec2& Proc_LoadObject::_internal_pos() const {
  const ::Proc_Vec2* p = _impl_.pos_;
  return p != nullptr ? *p : reinterpret_cast<const ::Proc_Vec2&>(
      ::_Proc_Vec2_default_instance_);
}
inline const ::Proc_Vec2& Proc_LoadObject::pos() const {
  // @@protoc_insertion_point(field_get:Proc_LoadObject.pos)
  return _internal_pos();
}
inline void Proc_LoadObject::unsafe_arena_set_allocated_pos(
    ::Proc_Vec2* pos) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pos_);
  }
  _impl_.pos_ = pos;
  if (pos) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Proc_LoadObject.pos)
}
inline ::Proc_Vec2* Proc_LoadObject::release_pos() {
  
  ::Proc_Vec2* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Proc_Vec2* Proc_LoadObject::unsafe_arena_release_pos() {
  // @@protoc_insertion_point(field_release:Proc_LoadObject.pos)
  
  ::Proc_Vec2* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
  return temp;
}
inline ::Proc_Vec2* Proc_LoadObject::_internal_mutable_pos() {
  
  if (_impl_.pos_ == nullptr) {
    auto* p = CreateMaybeMessage<::Proc_Vec2>(GetArenaForAllocation());
    _impl_.pos_ = p;
  }
  return _impl_.pos_;
}
inline ::Proc_Vec2* Proc_LoadObject::mutable_pos() {
  ::Proc_Vec2* _msg = _internal_mutable_pos();
  // @@protoc_insertion_point(field_mutable:Proc_LoadObject.pos)
  return _msg;
}
inline void Proc_LoadObject::set_allocated_pos(::Proc_Vec2* pos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.pos_;
  }
  if (pos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pos);
    if (message_arena != submessage_arena) {
      pos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pos, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.pos_ = pos;
  // @@protoc_insertion_point(field_set_allocated:Proc_LoadObject.pos)
}

// .Proc_Vec4 color = 3;
inline bool Proc_LoadObject::_internal_has_color() const {
  return this != internal_default_instance() && _impl_.color_ != nullptr;
}
inline bool Proc_LoadObject::has_color() const {
  return _internal_has_color();
}
inline void Proc_LoadObject::clear_color() {
  if (GetArenaForAllocation() == nullptr && _impl_.color_ != nullptr) {
    delete _impl_.color_;
  }
  _impl_.color_ = nullptr;
}
inline const ::Proc_Vec4& Proc_LoadObject::_internal_color() const {
  const ::Proc_Vec4* p = _impl_.color_;
  return p != nullptr ? *p : reinterpret_cast<const ::Proc_Vec4&>(
      ::_Proc_Vec4_default_instance_);
}
inline const ::Proc_Vec4& Proc_LoadObject::color() const {
  // @@protoc_insertion_point(field_get:Proc_LoadObject.color)
  return _internal_color();
}
inline void Proc_LoadObject::unsafe_arena_set_allocated_color(
    ::Proc_Vec4* color) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.color_);
  }
  _impl_.color_ = color;
  if (color) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Proc_LoadObject.color)
}
inline ::Proc_Vec4* Proc_LoadObject::release_color() {
  
  ::Proc_Vec4* temp = _impl_.color_;
  _impl_.color_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Proc_Vec4* Proc_LoadObject::unsafe_arena_release_color() {
  // @@protoc_insertion_point(field_release:Proc_LoadObject.color)
  
  ::Proc_Vec4* temp = _impl_.color_;
  _impl_.color_ = nullptr;
  return temp;
}
inline ::Proc_Vec4* Proc_LoadObject::_internal_mutable_color() {
  
  if (_impl_.color_ == nullptr) {
    auto* p = CreateMaybeMessage<::Proc_Vec4>(GetArenaForAllocation());
    _impl_.color_ = p;
  }
  return _impl_.color_;
}
inline ::Proc_Vec4* Proc_LoadObject::mutable_color() {
  ::Proc_Vec4* _msg = _internal_mutable_color();
  // @@protoc_insertion_point(field_mutable:Proc_LoadObject.color)
  return _msg;
}
inline void Proc_LoadObject::set_allocated_color(::Proc_Vec4* color) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.color_;
  }
  if (color) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(color);
    if (message_arena != submessage_arena) {
      color = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, color, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.color_ = color;
  // @@protoc_insertion_point(field_set_allocated:Proc_LoadObject.color)
}

// float angle = 4;
inline void Proc_LoadObject::clear_angle() {
  _impl_.angle_ = 0;
}
inline float Proc_LoadObject::_internal_angle() const {
  return _impl_.angle_;
}
inline float Proc_LoadObject::angle() const {
  // @@protoc_insertion_point(field_get:Proc_LoadObject.angle)
  return _internal_angle();
}
inline void Proc_LoadObject::_internal_set_angle(float value) {
  
  _impl_.angle_ = value;
}
inline void Proc_LoadObject::set_angle(float value) {
  _internal_set_angle(value);
  // @@protoc_insertion_point(field_set:Proc_LoadObject.angle)
}

// .Proc_Vec2 scale = 5;
inline bool Proc_LoadObject::_internal_has_scale() const {
  return this != internal_default_instance() && _impl_.scale_ != nullptr;
}
inline bool Proc_LoadObject::has_scale() const {
  return _internal_has_scale();
}
inline void Proc_LoadObject::clear_scale() {
  if (GetArenaForAllocation() == nullptr && _impl_.scale_ != nullptr) {
    delete _impl_.scale_;
  }
  _impl_.scale_ = nullptr;
}
inline const ::Proc_Vec2& Proc_LoadObject::_internal_scale() const {
  const ::Proc_Vec2* p = _impl_.scale_;
  return p != nullptr ? *p : reinterpret_cast<const ::Proc_Vec2&>(
      ::_Proc_Vec2_default_instance_);
}
inline const ::Proc_Vec2& Proc_LoadObject::scale() const {
  // @@protoc_insertion_point(field_get:Proc_LoadObject.scale)
  return _internal_scale();
}
inline void Proc_LoadObject::unsafe_arena_set_allocated_scale(
    ::Proc_Vec2* scale) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.scale_);
  }
  _impl_.scale_ = scale;
  if (scale) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Proc_LoadObject.scale)
}
inline ::Proc_Vec2* Proc_LoadObject::release_scale() {
  
  ::Proc_Vec2* temp = _impl_.scale_;
  _impl_.scale_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Proc_Vec2* Proc_LoadObject::unsafe_arena_release_scale() {
  // @@protoc_insertion_point(field_release:Proc_LoadObject.scale)
  
  ::Proc_Vec2* temp = _impl_.scale_;
  _impl_.scale_ = nullptr;
  return temp;
}
inline ::Proc_Vec2* Proc_LoadObject::_internal_mutable_scale() {
  
  if (_impl_.scale_ == nullptr) {
    auto* p = CreateMaybeMessage<::Proc_Vec2>(GetArenaForAllocation());
    _impl_.scale_ = p;
  }
  return _impl_.scale_;
}
inline ::Proc_Vec2* Proc_LoadObject::mutable_scale() {
  ::Proc_Vec2* _msg = _internal_mutable_scale();
  // @@protoc_insertion_point(field_mutable:Proc_LoadObject.scale)
  return _msg;
}
inline void Proc_LoadObject::set_allocated_scale(::Proc_Vec2* scale) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.scale_;
  }
  if (scale) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(scale);
    if (message_arena != submessage_arena) {
      scale = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, scale, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.scale_ = scale;
  // @@protoc_insertion_point(field_set_allocated:Proc_LoadObject.scale)
}

// -------------------------------------------------------------------

// Proc_Brush

// string textureName = 1;
inline void Proc_Brush::clear_texturename() {
  _impl_.texturename_.ClearToEmpty();
}
inline const std::string& Proc_Brush::texturename() const {
  // @@protoc_insertion_point(field_get:Proc_Brush.textureName)
  return _internal_texturename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Proc_Brush::set_texturename(ArgT0&& arg0, ArgT... args) {
 
 _impl_.texturename_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Proc_Brush.textureName)
}
inline std::string* Proc_Brush::mutable_texturename() {
  std::string* _s = _internal_mutable_texturename();
  // @@protoc_insertion_point(field_mutable:Proc_Brush.textureName)
  return _s;
}
inline const std::string& Proc_Brush::_internal_texturename() const {
  return _impl_.texturename_.Get();
}
inline void Proc_Brush::_internal_set_texturename(const std::string& value) {
  
  _impl_.texturename_.Set(value, GetArenaForAllocation());
}
inline std::string* Proc_Brush::_internal_mutable_texturename() {
  
  return _impl_.texturename_.Mutable(GetArenaForAllocation());
}
inline std::string* Proc_Brush::release_texturename() {
  // @@protoc_insertion_point(field_release:Proc_Brush.textureName)
  return _impl_.texturename_.Release();
}
inline void Proc_Brush::set_allocated_texturename(std::string* texturename) {
  if (texturename != nullptr) {
    
  } else {
    
  }
  _impl_.texturename_.SetAllocated(texturename, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.texturename_.IsDefault()) {
    _impl_.texturename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Proc_Brush.textureName)
}

// .Proc_Vec2 pos = 2;
inline bool Proc_Brush::_internal_has_pos() const {
  return this != internal_default_instance() && _impl_.pos_ != nullptr;
}
inline bool Proc_Brush::has_pos() const {
  return _internal_has_pos();
}
inline void Proc_Brush::clear_pos() {
  if (GetArenaForAllocation() == nullptr && _impl_.pos_ != nullptr) {
    delete _impl_.pos_;
  }
  _impl_.pos_ = nullptr;
}
inline const ::Proc_Vec2& Proc_Brush::_internal_pos() const {
  const ::Proc_Vec2* p = _impl_.pos_;
  return p != nullptr ? *p : reinterpret_cast<const ::Proc_Vec2&>(
      ::_Proc_Vec2_default_instance_);
}
inline const ::Proc_Vec2& Proc_Brush::pos() const {
  // @@protoc_insertion_point(field_get:Proc_Brush.pos)
  return _internal_pos();
}
inline void Proc_Brush::unsafe_arena_set_allocated_pos(
    ::Proc_Vec2* pos) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pos_);
  }
  _impl_.pos_ = pos;
  if (pos) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Proc_Brush.pos)
}
inline ::Proc_Vec2* Proc_Brush::release_pos() {
  
  ::Proc_Vec2* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Proc_Vec2* Proc_Brush::unsafe_arena_release_pos() {
  // @@protoc_insertion_point(field_release:Proc_Brush.pos)
  
  ::Proc_Vec2* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
  return temp;
}
inline ::Proc_Vec2* Proc_Brush::_internal_mutable_pos() {
  
  if (_impl_.pos_ == nullptr) {
    auto* p = CreateMaybeMessage<::Proc_Vec2>(GetArenaForAllocation());
    _impl_.pos_ = p;
  }
  return _impl_.pos_;
}
inline ::Proc_Vec2* Proc_Brush::mutable_pos() {
  ::Proc_Vec2* _msg = _internal_mutable_pos();
  // @@protoc_insertion_point(field_mutable:Proc_Brush.pos)
  return _msg;
}
inline void Proc_Brush::set_allocated_pos(::Proc_Vec2* pos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.pos_;
  }
  if (pos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pos);
    if (message_arena != submessage_arena) {
      pos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pos, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.pos_ = pos;
  // @@protoc_insertion_point(field_set_allocated:Proc_Brush.pos)
}

// .Proc_Vec2 dim = 3;
inline bool Proc_Brush::_internal_has_dim() const {
  return this != internal_default_instance() && _impl_.dim_ != nullptr;
}
inline bool Proc_Brush::has_dim() const {
  return _internal_has_dim();
}
inline void Proc_Brush::clear_dim() {
  if (GetArenaForAllocation() == nullptr && _impl_.dim_ != nullptr) {
    delete _impl_.dim_;
  }
  _impl_.dim_ = nullptr;
}
inline const ::Proc_Vec2& Proc_Brush::_internal_dim() const {
  const ::Proc_Vec2* p = _impl_.dim_;
  return p != nullptr ? *p : reinterpret_cast<const ::Proc_Vec2&>(
      ::_Proc_Vec2_default_instance_);
}
inline const ::Proc_Vec2& Proc_Brush::dim() const {
  // @@protoc_insertion_point(field_get:Proc_Brush.dim)
  return _internal_dim();
}
inline void Proc_Brush::unsafe_arena_set_allocated_dim(
    ::Proc_Vec2* dim) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.dim_);
  }
  _impl_.dim_ = dim;
  if (dim) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Proc_Brush.dim)
}
inline ::Proc_Vec2* Proc_Brush::release_dim() {
  
  ::Proc_Vec2* temp = _impl_.dim_;
  _impl_.dim_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Proc_Vec2* Proc_Brush::unsafe_arena_release_dim() {
  // @@protoc_insertion_point(field_release:Proc_Brush.dim)
  
  ::Proc_Vec2* temp = _impl_.dim_;
  _impl_.dim_ = nullptr;
  return temp;
}
inline ::Proc_Vec2* Proc_Brush::_internal_mutable_dim() {
  
  if (_impl_.dim_ == nullptr) {
    auto* p = CreateMaybeMessage<::Proc_Vec2>(GetArenaForAllocation());
    _impl_.dim_ = p;
  }
  return _impl_.dim_;
}
inline ::Proc_Vec2* Proc_Brush::mutable_dim() {
  ::Proc_Vec2* _msg = _internal_mutable_dim();
  // @@protoc_insertion_point(field_mutable:Proc_Brush.dim)
  return _msg;
}
inline void Proc_Brush::set_allocated_dim(::Proc_Vec2* dim) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.dim_;
  }
  if (dim) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(dim);
    if (message_arena != submessage_arena) {
      dim = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dim, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.dim_ = dim;
  // @@protoc_insertion_point(field_set_allocated:Proc_Brush.dim)
}

// .Proc_Vec2 uv = 4;
inline bool Proc_Brush::_internal_has_uv() const {
  return this != internal_default_instance() && _impl_.uv_ != nullptr;
}
inline bool Proc_Brush::has_uv() const {
  return _internal_has_uv();
}
inline void Proc_Brush::clear_uv() {
  if (GetArenaForAllocation() == nullptr && _impl_.uv_ != nullptr) {
    delete _impl_.uv_;
  }
  _impl_.uv_ = nullptr;
}
inline const ::Proc_Vec2& Proc_Brush::_internal_uv() const {
  const ::Proc_Vec2* p = _impl_.uv_;
  return p != nullptr ? *p : reinterpret_cast<const ::Proc_Vec2&>(
      ::_Proc_Vec2_default_instance_);
}
inline const ::Proc_Vec2& Proc_Brush::uv() const {
  // @@protoc_insertion_point(field_get:Proc_Brush.uv)
  return _internal_uv();
}
inline void Proc_Brush::unsafe_arena_set_allocated_uv(
    ::Proc_Vec2* uv) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.uv_);
  }
  _impl_.uv_ = uv;
  if (uv) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Proc_Brush.uv)
}
inline ::Proc_Vec2* Proc_Brush::release_uv() {
  
  ::Proc_Vec2* temp = _impl_.uv_;
  _impl_.uv_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Proc_Vec2* Proc_Brush::unsafe_arena_release_uv() {
  // @@protoc_insertion_point(field_release:Proc_Brush.uv)
  
  ::Proc_Vec2* temp = _impl_.uv_;
  _impl_.uv_ = nullptr;
  return temp;
}
inline ::Proc_Vec2* Proc_Brush::_internal_mutable_uv() {
  
  if (_impl_.uv_ == nullptr) {
    auto* p = CreateMaybeMessage<::Proc_Vec2>(GetArenaForAllocation());
    _impl_.uv_ = p;
  }
  return _impl_.uv_;
}
inline ::Proc_Vec2* Proc_Brush::mutable_uv() {
  ::Proc_Vec2* _msg = _internal_mutable_uv();
  // @@protoc_insertion_point(field_mutable:Proc_Brush.uv)
  return _msg;
}
inline void Proc_Brush::set_allocated_uv(::Proc_Vec2* uv) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.uv_;
  }
  if (uv) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(uv);
    if (message_arena != submessage_arena) {
      uv = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, uv, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.uv_ = uv;
  // @@protoc_insertion_point(field_set_allocated:Proc_Brush.uv)
}

// float depth = 5;
inline void Proc_Brush::clear_depth() {
  _impl_.depth_ = 0;
}
inline float Proc_Brush::_internal_depth() const {
  return _impl_.depth_;
}
inline float Proc_Brush::depth() const {
  // @@protoc_insertion_point(field_get:Proc_Brush.depth)
  return _internal_depth();
}
inline void Proc_Brush::_internal_set_depth(float value) {
  
  _impl_.depth_ = value;
}
inline void Proc_Brush::set_depth(float value) {
  _internal_set_depth(value);
  // @@protoc_insertion_point(field_set:Proc_Brush.depth)
}

// -------------------------------------------------------------------

// Proc_Layer

// string name = 1;
inline void Proc_Layer::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Proc_Layer::name() const {
  // @@protoc_insertion_point(field_get:Proc_Layer.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Proc_Layer::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Proc_Layer.name)
}
inline std::string* Proc_Layer::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:Proc_Layer.name)
  return _s;
}
inline const std::string& Proc_Layer::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Proc_Layer::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Proc_Layer::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Proc_Layer::release_name() {
  // @@protoc_insertion_point(field_release:Proc_Layer.name)
  return _impl_.name_.Release();
}
inline void Proc_Layer::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Proc_Layer.name)
}

// int32 depth = 2;
inline void Proc_Layer::clear_depth() {
  _impl_.depth_ = 0;
}
inline int32_t Proc_Layer::_internal_depth() const {
  return _impl_.depth_;
}
inline int32_t Proc_Layer::depth() const {
  // @@protoc_insertion_point(field_get:Proc_Layer.depth)
  return _internal_depth();
}
inline void Proc_Layer::_internal_set_depth(int32_t value) {
  
  _impl_.depth_ = value;
}
inline void Proc_Layer::set_depth(int32_t value) {
  _internal_set_depth(value);
  // @@protoc_insertion_point(field_set:Proc_Layer.depth)
}

// repeated .Proc_LoadObject objectList = 3;
inline int Proc_Layer::_internal_objectlist_size() const {
  return _impl_.objectlist_.size();
}
inline int Proc_Layer::objectlist_size() const {
  return _internal_objectlist_size();
}
inline void Proc_Layer::clear_objectlist() {
  _impl_.objectlist_.Clear();
}
inline ::Proc_LoadObject* Proc_Layer::mutable_objectlist(int index) {
  // @@protoc_insertion_point(field_mutable:Proc_Layer.objectList)
  return _impl_.objectlist_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Proc_LoadObject >*
Proc_Layer::mutable_objectlist() {
  // @@protoc_insertion_point(field_mutable_list:Proc_Layer.objectList)
  return &_impl_.objectlist_;
}
inline const ::Proc_LoadObject& Proc_Layer::_internal_objectlist(int index) const {
  return _impl_.objectlist_.Get(index);
}
inline const ::Proc_LoadObject& Proc_Layer::objectlist(int index) const {
  // @@protoc_insertion_point(field_get:Proc_Layer.objectList)
  return _internal_objectlist(index);
}
inline ::Proc_LoadObject* Proc_Layer::_internal_add_objectlist() {
  return _impl_.objectlist_.Add();
}
inline ::Proc_LoadObject* Proc_Layer::add_objectlist() {
  ::Proc_LoadObject* _add = _internal_add_objectlist();
  // @@protoc_insertion_point(field_add:Proc_Layer.objectList)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Proc_LoadObject >&
Proc_Layer::objectlist() const {
  // @@protoc_insertion_point(field_list:Proc_Layer.objectList)
  return _impl_.objectlist_;
}

// repeated .Proc_Brush brushList = 4;
inline int Proc_Layer::_internal_brushlist_size() const {
  return _impl_.brushlist_.size();
}
inline int Proc_Layer::brushlist_size() const {
  return _internal_brushlist_size();
}
inline void Proc_Layer::clear_brushlist() {
  _impl_.brushlist_.Clear();
}
inline ::Proc_Brush* Proc_Layer::mutable_brushlist(int index) {
  // @@protoc_insertion_point(field_mutable:Proc_Layer.brushList)
  return _impl_.brushlist_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Proc_Brush >*
Proc_Layer::mutable_brushlist() {
  // @@protoc_insertion_point(field_mutable_list:Proc_Layer.brushList)
  return &_impl_.brushlist_;
}
inline const ::Proc_Brush& Proc_Layer::_internal_brushlist(int index) const {
  return _impl_.brushlist_.Get(index);
}
inline const ::Proc_Brush& Proc_Layer::brushlist(int index) const {
  // @@protoc_insertion_point(field_get:Proc_Layer.brushList)
  return _internal_brushlist(index);
}
inline ::Proc_Brush* Proc_Layer::_internal_add_brushlist() {
  return _impl_.brushlist_.Add();
}
inline ::Proc_Brush* Proc_Layer::add_brushlist() {
  ::Proc_Brush* _add = _internal_add_brushlist();
  // @@protoc_insertion_point(field_add:Proc_Layer.brushList)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Proc_Brush >&
Proc_Layer::brushlist() const {
  // @@protoc_insertion_point(field_list:Proc_Layer.brushList)
  return _impl_.brushlist_;
}

// -------------------------------------------------------------------

// Proc_Scene

// string name = 1;
inline void Proc_Scene::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Proc_Scene::name() const {
  // @@protoc_insertion_point(field_get:Proc_Scene.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Proc_Scene::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Proc_Scene.name)
}
inline std::string* Proc_Scene::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:Proc_Scene.name)
  return _s;
}
inline const std::string& Proc_Scene::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Proc_Scene::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Proc_Scene::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Proc_Scene::release_name() {
  // @@protoc_insertion_point(field_release:Proc_Scene.name)
  return _impl_.name_.Release();
}
inline void Proc_Scene::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Proc_Scene.name)
}

// repeated .Proc_Layer layerList = 2;
inline int Proc_Scene::_internal_layerlist_size() const {
  return _impl_.layerlist_.size();
}
inline int Proc_Scene::layerlist_size() const {
  return _internal_layerlist_size();
}
inline void Proc_Scene::clear_layerlist() {
  _impl_.layerlist_.Clear();
}
inline ::Proc_Layer* Proc_Scene::mutable_layerlist(int index) {
  // @@protoc_insertion_point(field_mutable:Proc_Scene.layerList)
  return _impl_.layerlist_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Proc_Layer >*
Proc_Scene::mutable_layerlist() {
  // @@protoc_insertion_point(field_mutable_list:Proc_Scene.layerList)
  return &_impl_.layerlist_;
}
inline const ::Proc_Layer& Proc_Scene::_internal_layerlist(int index) const {
  return _impl_.layerlist_.Get(index);
}
inline const ::Proc_Layer& Proc_Scene::layerlist(int index) const {
  // @@protoc_insertion_point(field_get:Proc_Scene.layerList)
  return _internal_layerlist(index);
}
inline ::Proc_Layer* Proc_Scene::_internal_add_layerlist() {
  return _impl_.layerlist_.Add();
}
inline ::Proc_Layer* Proc_Scene::add_layerlist() {
  ::Proc_Layer* _add = _internal_add_layerlist();
  // @@protoc_insertion_point(field_add:Proc_Scene.layerList)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Proc_Layer >&
Proc_Scene::layerlist() const {
  // @@protoc_insertion_point(field_list:Proc_Scene.layerList)
  return _impl_.layerlist_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_objectData_2eproto
