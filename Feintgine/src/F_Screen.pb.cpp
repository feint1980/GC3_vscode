// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: F_Screen.proto

#include "F_Screen.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

PROTOBUF_CONSTEXPR Proc_Vec2::Proc_Vec2(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.valuex_)*/0
  , /*decltype(_impl_.valuey_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Proc_Vec2DefaultTypeInternal {
  PROTOBUF_CONSTEXPR Proc_Vec2DefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Proc_Vec2DefaultTypeInternal() {}
  union {
    Proc_Vec2 _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Proc_Vec2DefaultTypeInternal _Proc_Vec2_default_instance_;
PROTOBUF_CONSTEXPR Proc_Vec3::Proc_Vec3(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.valuex_)*/0
  , /*decltype(_impl_.valuey_)*/0
  , /*decltype(_impl_.valuez_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Proc_Vec3DefaultTypeInternal {
  PROTOBUF_CONSTEXPR Proc_Vec3DefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Proc_Vec3DefaultTypeInternal() {}
  union {
    Proc_Vec3 _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Proc_Vec3DefaultTypeInternal _Proc_Vec3_default_instance_;
PROTOBUF_CONSTEXPR Proc_Vec4::Proc_Vec4(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.valuex_)*/0
  , /*decltype(_impl_.valuey_)*/0
  , /*decltype(_impl_.valuez_)*/0
  , /*decltype(_impl_.valuew_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Proc_Vec4DefaultTypeInternal {
  PROTOBUF_CONSTEXPR Proc_Vec4DefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Proc_Vec4DefaultTypeInternal() {}
  union {
    Proc_Vec4 _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Proc_Vec4DefaultTypeInternal _Proc_Vec4_default_instance_;
PROTOBUF_CONSTEXPR Proc_SpotLight::Proc_SpotLight(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.pos_)*/nullptr
  , /*decltype(_impl_.color_)*/nullptr
  , /*decltype(_impl_.atenuation_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Proc_SpotLightDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Proc_SpotLightDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Proc_SpotLightDefaultTypeInternal() {}
  union {
    Proc_SpotLight _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Proc_SpotLightDefaultTypeInternal _Proc_SpotLight_default_instance_;
PROTOBUF_CONSTEXPR Proc_ColiderBox::Proc_ColiderBox(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.pos_)*/nullptr
  , /*decltype(_impl_.dim_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Proc_ColiderBoxDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Proc_ColiderBoxDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Proc_ColiderBoxDefaultTypeInternal() {}
  union {
    Proc_ColiderBox _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Proc_ColiderBoxDefaultTypeInternal _Proc_ColiderBox_default_instance_;
PROTOBUF_CONSTEXPR Proc_Sprite::Proc_Sprite(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.texturepath_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.packetname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.dim_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Proc_SpriteDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Proc_SpriteDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Proc_SpriteDefaultTypeInternal() {}
  union {
    Proc_Sprite _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Proc_SpriteDefaultTypeInternal _Proc_Sprite_default_instance_;
PROTOBUF_CONSTEXPR Proc_OwnSprite::Proc_OwnSprite(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.proc_sprite_)*/nullptr
  , /*decltype(_impl_.offsetpos_)*/nullptr
  , /*decltype(_impl_.offsetscale_)*/nullptr
  , /*decltype(_impl_.color_)*/nullptr
  , /*decltype(_impl_.depth_)*/0
  , /*decltype(_impl_.angle_)*/0} {}
struct Proc_OwnSpriteDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Proc_OwnSpriteDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Proc_OwnSpriteDefaultTypeInternal() {}
  union {
    Proc_OwnSprite _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Proc_OwnSpriteDefaultTypeInternal _Proc_OwnSprite_default_instance_;
PROTOBUF_CONSTEXPR Proc_Object::Proc_Object(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.proc_spritelist_)*/{}
  , /*decltype(_impl_.lightlist_)*/{}
  , /*decltype(_impl_.coliderlist_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Proc_ObjectDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Proc_ObjectDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Proc_ObjectDefaultTypeInternal() {}
  union {
    Proc_Object _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Proc_ObjectDefaultTypeInternal _Proc_Object_default_instance_;
static ::_pb::Metadata file_level_metadata_F_5fScreen_2eproto[8];
static constexpr ::_pb::EnumDescriptor const** file_level_enum_descriptors_F_5fScreen_2eproto = nullptr;
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_F_5fScreen_2eproto = nullptr;

const uint32_t TableStruct_F_5fScreen_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Proc_Vec2, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Proc_Vec2, _impl_.valuex_),
  PROTOBUF_FIELD_OFFSET(::Proc_Vec2, _impl_.valuey_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Proc_Vec3, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Proc_Vec3, _impl_.valuex_),
  PROTOBUF_FIELD_OFFSET(::Proc_Vec3, _impl_.valuey_),
  PROTOBUF_FIELD_OFFSET(::Proc_Vec3, _impl_.valuez_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Proc_Vec4, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Proc_Vec4, _impl_.valuex_),
  PROTOBUF_FIELD_OFFSET(::Proc_Vec4, _impl_.valuey_),
  PROTOBUF_FIELD_OFFSET(::Proc_Vec4, _impl_.valuez_),
  PROTOBUF_FIELD_OFFSET(::Proc_Vec4, _impl_.valuew_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Proc_SpotLight, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Proc_SpotLight, _impl_.pos_),
  PROTOBUF_FIELD_OFFSET(::Proc_SpotLight, _impl_.color_),
  PROTOBUF_FIELD_OFFSET(::Proc_SpotLight, _impl_.atenuation_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Proc_ColiderBox, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Proc_ColiderBox, _impl_.pos_),
  PROTOBUF_FIELD_OFFSET(::Proc_ColiderBox, _impl_.dim_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Proc_Sprite, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Proc_Sprite, _impl_.texturepath_),
  PROTOBUF_FIELD_OFFSET(::Proc_Sprite, _impl_.dim_),
  PROTOBUF_FIELD_OFFSET(::Proc_Sprite, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::Proc_Sprite, _impl_.packetname_),
  PROTOBUF_FIELD_OFFSET(::Proc_OwnSprite, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::Proc_OwnSprite, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Proc_OwnSprite, _impl_.proc_sprite_),
  PROTOBUF_FIELD_OFFSET(::Proc_OwnSprite, _impl_.offsetpos_),
  PROTOBUF_FIELD_OFFSET(::Proc_OwnSprite, _impl_.offsetscale_),
  PROTOBUF_FIELD_OFFSET(::Proc_OwnSprite, _impl_.color_),
  PROTOBUF_FIELD_OFFSET(::Proc_OwnSprite, _impl_.depth_),
  PROTOBUF_FIELD_OFFSET(::Proc_OwnSprite, _impl_.angle_),
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  0,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Proc_Object, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Proc_Object, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::Proc_Object, _impl_.proc_spritelist_),
  PROTOBUF_FIELD_OFFSET(::Proc_Object, _impl_.lightlist_),
  PROTOBUF_FIELD_OFFSET(::Proc_Object, _impl_.coliderlist_),
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::Proc_Vec2)},
  { 8, -1, -1, sizeof(::Proc_Vec3)},
  { 17, -1, -1, sizeof(::Proc_Vec4)},
  { 27, -1, -1, sizeof(::Proc_SpotLight)},
  { 36, -1, -1, sizeof(::Proc_ColiderBox)},
  { 44, -1, -1, sizeof(::Proc_Sprite)},
  { 54, 66, -1, sizeof(::Proc_OwnSprite)},
  { 72, -1, -1, sizeof(::Proc_Object)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::_Proc_Vec2_default_instance_._instance,
  &::_Proc_Vec3_default_instance_._instance,
  &::_Proc_Vec4_default_instance_._instance,
  &::_Proc_SpotLight_default_instance_._instance,
  &::_Proc_ColiderBox_default_instance_._instance,
  &::_Proc_Sprite_default_instance_._instance,
  &::_Proc_OwnSprite_default_instance_._instance,
  &::_Proc_Object_default_instance_._instance,
};

const char descriptor_table_protodef_F_5fScreen_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\016F_Screen.proto\"+\n\tProc_Vec2\022\016\n\006valueX\030"
  "\001 \001(\002\022\016\n\006valueY\030\002 \001(\002\";\n\tProc_Vec3\022\016\n\006va"
  "lueX\030\001 \001(\002\022\016\n\006valueY\030\002 \001(\002\022\016\n\006valueZ\030\003 \001"
  "(\002\"K\n\tProc_Vec4\022\016\n\006valueX\030\001 \001(\002\022\016\n\006value"
  "Y\030\002 \001(\002\022\016\n\006valueZ\030\003 \001(\002\022\016\n\006valueW\030\004 \001(\002\""
  "d\n\016Proc_SpotLight\022\027\n\003pos\030\001 \001(\0132\n.Proc_Ve"
  "c2\022\031\n\005color\030\002 \001(\0132\n.Proc_Vec4\022\036\n\natenuat"
  "ion\030\003 \001(\0132\n.Proc_Vec3\"C\n\017Proc_ColiderBox"
  "\022\027\n\003pos\030\001 \001(\0132\n.Proc_Vec2\022\027\n\003dim\030\002 \001(\0132\n"
  ".Proc_Vec2\"]\n\013Proc_Sprite\022\023\n\013texturePath"
  "\030\001 \001(\t\022\027\n\003dim\030\002 \001(\0132\n.Proc_Vec2\022\014\n\004name\030"
  "\003 \001(\t\022\022\n\npacketName\030\004 \001(\t\"\273\001\n\016Proc_OwnSp"
  "rite\022!\n\013Proc_Sprite\030\001 \001(\0132\014.Proc_Sprite\022"
  "\035\n\toffsetPos\030\002 \001(\0132\n.Proc_Vec2\022\037\n\013offset"
  "Scale\030\003 \001(\0132\n.Proc_Vec2\022\031\n\005color\030\004 \001(\0132\n"
  ".Proc_Vec4\022\r\n\005depth\030\005 \001(\002\022\022\n\005angle\030\006 \001(\002"
  "H\000\210\001\001B\010\n\006_angle\"\220\001\n\013Proc_Object\022\014\n\004name\030"
  "\001 \001(\t\022(\n\017Proc_SpriteList\030\002 \003(\0132\017.Proc_Ow"
  "nSprite\022\"\n\tlightList\030\003 \003(\0132\017.Proc_SpotLi"
  "ght\022%\n\013coliderList\030\004 \003(\0132\020.Proc_ColiderB"
  "oxb\006proto3"
  ;
static ::_pbi::once_flag descriptor_table_F_5fScreen_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_F_5fScreen_2eproto = {
    false, false, 810, descriptor_table_protodef_F_5fScreen_2eproto,
    "F_Screen.proto",
    &descriptor_table_F_5fScreen_2eproto_once, nullptr, 0, 8,
    schemas, file_default_instances, TableStruct_F_5fScreen_2eproto::offsets,
    file_level_metadata_F_5fScreen_2eproto, file_level_enum_descriptors_F_5fScreen_2eproto,
    file_level_service_descriptors_F_5fScreen_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_F_5fScreen_2eproto_getter() {
  return &descriptor_table_F_5fScreen_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_F_5fScreen_2eproto(&descriptor_table_F_5fScreen_2eproto);

// ===================================================================

class Proc_Vec2::_Internal {
 public:
};

Proc_Vec2::Proc_Vec2(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Proc_Vec2)
}
Proc_Vec2::Proc_Vec2(const Proc_Vec2& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Proc_Vec2* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.valuex_){}
    , decltype(_impl_.valuey_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.valuex_, &from._impl_.valuex_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.valuey_) -
    reinterpret_cast<char*>(&_impl_.valuex_)) + sizeof(_impl_.valuey_));
  // @@protoc_insertion_point(copy_constructor:Proc_Vec2)
}

inline void Proc_Vec2::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.valuex_){0}
    , decltype(_impl_.valuey_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Proc_Vec2::~Proc_Vec2() {
  // @@protoc_insertion_point(destructor:Proc_Vec2)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Proc_Vec2::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Proc_Vec2::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Proc_Vec2::Clear() {
// @@protoc_insertion_point(message_clear_start:Proc_Vec2)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.valuex_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.valuey_) -
      reinterpret_cast<char*>(&_impl_.valuex_)) + sizeof(_impl_.valuey_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Proc_Vec2::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float valueX = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _impl_.valuex_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float valueY = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _impl_.valuey_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Proc_Vec2::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Proc_Vec2)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float valueX = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_valuex = this->_internal_valuex();
  uint32_t raw_valuex;
  memcpy(&raw_valuex, &tmp_valuex, sizeof(tmp_valuex));
  if (raw_valuex != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(1, this->_internal_valuex(), target);
  }

  // float valueY = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_valuey = this->_internal_valuey();
  uint32_t raw_valuey;
  memcpy(&raw_valuey, &tmp_valuey, sizeof(tmp_valuey));
  if (raw_valuey != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_valuey(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Proc_Vec2)
  return target;
}

size_t Proc_Vec2::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Proc_Vec2)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float valueX = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_valuex = this->_internal_valuex();
  uint32_t raw_valuex;
  memcpy(&raw_valuex, &tmp_valuex, sizeof(tmp_valuex));
  if (raw_valuex != 0) {
    total_size += 1 + 4;
  }

  // float valueY = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_valuey = this->_internal_valuey();
  uint32_t raw_valuey;
  memcpy(&raw_valuey, &tmp_valuey, sizeof(tmp_valuey));
  if (raw_valuey != 0) {
    total_size += 1 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Proc_Vec2::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Proc_Vec2::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Proc_Vec2::GetClassData() const { return &_class_data_; }


void Proc_Vec2::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Proc_Vec2*>(&to_msg);
  auto& from = static_cast<const Proc_Vec2&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Proc_Vec2)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_valuex = from._internal_valuex();
  uint32_t raw_valuex;
  memcpy(&raw_valuex, &tmp_valuex, sizeof(tmp_valuex));
  if (raw_valuex != 0) {
    _this->_internal_set_valuex(from._internal_valuex());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_valuey = from._internal_valuey();
  uint32_t raw_valuey;
  memcpy(&raw_valuey, &tmp_valuey, sizeof(tmp_valuey));
  if (raw_valuey != 0) {
    _this->_internal_set_valuey(from._internal_valuey());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Proc_Vec2::CopyFrom(const Proc_Vec2& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Proc_Vec2)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Proc_Vec2::IsInitialized() const {
  return true;
}

void Proc_Vec2::InternalSwap(Proc_Vec2* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Proc_Vec2, _impl_.valuey_)
      + sizeof(Proc_Vec2::_impl_.valuey_)
      - PROTOBUF_FIELD_OFFSET(Proc_Vec2, _impl_.valuex_)>(
          reinterpret_cast<char*>(&_impl_.valuex_),
          reinterpret_cast<char*>(&other->_impl_.valuex_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Proc_Vec2::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_F_5fScreen_2eproto_getter, &descriptor_table_F_5fScreen_2eproto_once,
      file_level_metadata_F_5fScreen_2eproto[0]);
}

// ===================================================================

class Proc_Vec3::_Internal {
 public:
};

Proc_Vec3::Proc_Vec3(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Proc_Vec3)
}
Proc_Vec3::Proc_Vec3(const Proc_Vec3& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Proc_Vec3* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.valuex_){}
    , decltype(_impl_.valuey_){}
    , decltype(_impl_.valuez_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.valuex_, &from._impl_.valuex_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.valuez_) -
    reinterpret_cast<char*>(&_impl_.valuex_)) + sizeof(_impl_.valuez_));
  // @@protoc_insertion_point(copy_constructor:Proc_Vec3)
}

inline void Proc_Vec3::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.valuex_){0}
    , decltype(_impl_.valuey_){0}
    , decltype(_impl_.valuez_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Proc_Vec3::~Proc_Vec3() {
  // @@protoc_insertion_point(destructor:Proc_Vec3)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Proc_Vec3::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Proc_Vec3::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Proc_Vec3::Clear() {
// @@protoc_insertion_point(message_clear_start:Proc_Vec3)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.valuex_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.valuez_) -
      reinterpret_cast<char*>(&_impl_.valuex_)) + sizeof(_impl_.valuez_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Proc_Vec3::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float valueX = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _impl_.valuex_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float valueY = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _impl_.valuey_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float valueZ = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _impl_.valuez_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Proc_Vec3::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Proc_Vec3)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float valueX = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_valuex = this->_internal_valuex();
  uint32_t raw_valuex;
  memcpy(&raw_valuex, &tmp_valuex, sizeof(tmp_valuex));
  if (raw_valuex != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(1, this->_internal_valuex(), target);
  }

  // float valueY = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_valuey = this->_internal_valuey();
  uint32_t raw_valuey;
  memcpy(&raw_valuey, &tmp_valuey, sizeof(tmp_valuey));
  if (raw_valuey != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_valuey(), target);
  }

  // float valueZ = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_valuez = this->_internal_valuez();
  uint32_t raw_valuez;
  memcpy(&raw_valuez, &tmp_valuez, sizeof(tmp_valuez));
  if (raw_valuez != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_valuez(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Proc_Vec3)
  return target;
}

size_t Proc_Vec3::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Proc_Vec3)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float valueX = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_valuex = this->_internal_valuex();
  uint32_t raw_valuex;
  memcpy(&raw_valuex, &tmp_valuex, sizeof(tmp_valuex));
  if (raw_valuex != 0) {
    total_size += 1 + 4;
  }

  // float valueY = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_valuey = this->_internal_valuey();
  uint32_t raw_valuey;
  memcpy(&raw_valuey, &tmp_valuey, sizeof(tmp_valuey));
  if (raw_valuey != 0) {
    total_size += 1 + 4;
  }

  // float valueZ = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_valuez = this->_internal_valuez();
  uint32_t raw_valuez;
  memcpy(&raw_valuez, &tmp_valuez, sizeof(tmp_valuez));
  if (raw_valuez != 0) {
    total_size += 1 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Proc_Vec3::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Proc_Vec3::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Proc_Vec3::GetClassData() const { return &_class_data_; }


void Proc_Vec3::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Proc_Vec3*>(&to_msg);
  auto& from = static_cast<const Proc_Vec3&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Proc_Vec3)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_valuex = from._internal_valuex();
  uint32_t raw_valuex;
  memcpy(&raw_valuex, &tmp_valuex, sizeof(tmp_valuex));
  if (raw_valuex != 0) {
    _this->_internal_set_valuex(from._internal_valuex());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_valuey = from._internal_valuey();
  uint32_t raw_valuey;
  memcpy(&raw_valuey, &tmp_valuey, sizeof(tmp_valuey));
  if (raw_valuey != 0) {
    _this->_internal_set_valuey(from._internal_valuey());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_valuez = from._internal_valuez();
  uint32_t raw_valuez;
  memcpy(&raw_valuez, &tmp_valuez, sizeof(tmp_valuez));
  if (raw_valuez != 0) {
    _this->_internal_set_valuez(from._internal_valuez());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Proc_Vec3::CopyFrom(const Proc_Vec3& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Proc_Vec3)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Proc_Vec3::IsInitialized() const {
  return true;
}

void Proc_Vec3::InternalSwap(Proc_Vec3* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Proc_Vec3, _impl_.valuez_)
      + sizeof(Proc_Vec3::_impl_.valuez_)
      - PROTOBUF_FIELD_OFFSET(Proc_Vec3, _impl_.valuex_)>(
          reinterpret_cast<char*>(&_impl_.valuex_),
          reinterpret_cast<char*>(&other->_impl_.valuex_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Proc_Vec3::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_F_5fScreen_2eproto_getter, &descriptor_table_F_5fScreen_2eproto_once,
      file_level_metadata_F_5fScreen_2eproto[1]);
}

// ===================================================================

class Proc_Vec4::_Internal {
 public:
};

Proc_Vec4::Proc_Vec4(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Proc_Vec4)
}
Proc_Vec4::Proc_Vec4(const Proc_Vec4& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Proc_Vec4* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.valuex_){}
    , decltype(_impl_.valuey_){}
    , decltype(_impl_.valuez_){}
    , decltype(_impl_.valuew_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.valuex_, &from._impl_.valuex_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.valuew_) -
    reinterpret_cast<char*>(&_impl_.valuex_)) + sizeof(_impl_.valuew_));
  // @@protoc_insertion_point(copy_constructor:Proc_Vec4)
}

inline void Proc_Vec4::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.valuex_){0}
    , decltype(_impl_.valuey_){0}
    , decltype(_impl_.valuez_){0}
    , decltype(_impl_.valuew_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Proc_Vec4::~Proc_Vec4() {
  // @@protoc_insertion_point(destructor:Proc_Vec4)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Proc_Vec4::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Proc_Vec4::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Proc_Vec4::Clear() {
// @@protoc_insertion_point(message_clear_start:Proc_Vec4)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.valuex_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.valuew_) -
      reinterpret_cast<char*>(&_impl_.valuex_)) + sizeof(_impl_.valuew_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Proc_Vec4::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float valueX = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _impl_.valuex_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float valueY = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _impl_.valuey_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float valueZ = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _impl_.valuez_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float valueW = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _impl_.valuew_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Proc_Vec4::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Proc_Vec4)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float valueX = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_valuex = this->_internal_valuex();
  uint32_t raw_valuex;
  memcpy(&raw_valuex, &tmp_valuex, sizeof(tmp_valuex));
  if (raw_valuex != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(1, this->_internal_valuex(), target);
  }

  // float valueY = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_valuey = this->_internal_valuey();
  uint32_t raw_valuey;
  memcpy(&raw_valuey, &tmp_valuey, sizeof(tmp_valuey));
  if (raw_valuey != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_valuey(), target);
  }

  // float valueZ = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_valuez = this->_internal_valuez();
  uint32_t raw_valuez;
  memcpy(&raw_valuez, &tmp_valuez, sizeof(tmp_valuez));
  if (raw_valuez != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_valuez(), target);
  }

  // float valueW = 4;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_valuew = this->_internal_valuew();
  uint32_t raw_valuew;
  memcpy(&raw_valuew, &tmp_valuew, sizeof(tmp_valuew));
  if (raw_valuew != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_valuew(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Proc_Vec4)
  return target;
}

size_t Proc_Vec4::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Proc_Vec4)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float valueX = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_valuex = this->_internal_valuex();
  uint32_t raw_valuex;
  memcpy(&raw_valuex, &tmp_valuex, sizeof(tmp_valuex));
  if (raw_valuex != 0) {
    total_size += 1 + 4;
  }

  // float valueY = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_valuey = this->_internal_valuey();
  uint32_t raw_valuey;
  memcpy(&raw_valuey, &tmp_valuey, sizeof(tmp_valuey));
  if (raw_valuey != 0) {
    total_size += 1 + 4;
  }

  // float valueZ = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_valuez = this->_internal_valuez();
  uint32_t raw_valuez;
  memcpy(&raw_valuez, &tmp_valuez, sizeof(tmp_valuez));
  if (raw_valuez != 0) {
    total_size += 1 + 4;
  }

  // float valueW = 4;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_valuew = this->_internal_valuew();
  uint32_t raw_valuew;
  memcpy(&raw_valuew, &tmp_valuew, sizeof(tmp_valuew));
  if (raw_valuew != 0) {
    total_size += 1 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Proc_Vec4::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Proc_Vec4::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Proc_Vec4::GetClassData() const { return &_class_data_; }


void Proc_Vec4::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Proc_Vec4*>(&to_msg);
  auto& from = static_cast<const Proc_Vec4&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Proc_Vec4)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_valuex = from._internal_valuex();
  uint32_t raw_valuex;
  memcpy(&raw_valuex, &tmp_valuex, sizeof(tmp_valuex));
  if (raw_valuex != 0) {
    _this->_internal_set_valuex(from._internal_valuex());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_valuey = from._internal_valuey();
  uint32_t raw_valuey;
  memcpy(&raw_valuey, &tmp_valuey, sizeof(tmp_valuey));
  if (raw_valuey != 0) {
    _this->_internal_set_valuey(from._internal_valuey());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_valuez = from._internal_valuez();
  uint32_t raw_valuez;
  memcpy(&raw_valuez, &tmp_valuez, sizeof(tmp_valuez));
  if (raw_valuez != 0) {
    _this->_internal_set_valuez(from._internal_valuez());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_valuew = from._internal_valuew();
  uint32_t raw_valuew;
  memcpy(&raw_valuew, &tmp_valuew, sizeof(tmp_valuew));
  if (raw_valuew != 0) {
    _this->_internal_set_valuew(from._internal_valuew());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Proc_Vec4::CopyFrom(const Proc_Vec4& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Proc_Vec4)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Proc_Vec4::IsInitialized() const {
  return true;
}

void Proc_Vec4::InternalSwap(Proc_Vec4* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Proc_Vec4, _impl_.valuew_)
      + sizeof(Proc_Vec4::_impl_.valuew_)
      - PROTOBUF_FIELD_OFFSET(Proc_Vec4, _impl_.valuex_)>(
          reinterpret_cast<char*>(&_impl_.valuex_),
          reinterpret_cast<char*>(&other->_impl_.valuex_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Proc_Vec4::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_F_5fScreen_2eproto_getter, &descriptor_table_F_5fScreen_2eproto_once,
      file_level_metadata_F_5fScreen_2eproto[2]);
}

// ===================================================================

class Proc_SpotLight::_Internal {
 public:
  static const ::Proc_Vec2& pos(const Proc_SpotLight* msg);
  static const ::Proc_Vec4& color(const Proc_SpotLight* msg);
  static const ::Proc_Vec3& atenuation(const Proc_SpotLight* msg);
};

const ::Proc_Vec2&
Proc_SpotLight::_Internal::pos(const Proc_SpotLight* msg) {
  return *msg->_impl_.pos_;
}
const ::Proc_Vec4&
Proc_SpotLight::_Internal::color(const Proc_SpotLight* msg) {
  return *msg->_impl_.color_;
}
const ::Proc_Vec3&
Proc_SpotLight::_Internal::atenuation(const Proc_SpotLight* msg) {
  return *msg->_impl_.atenuation_;
}
Proc_SpotLight::Proc_SpotLight(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Proc_SpotLight)
}
Proc_SpotLight::Proc_SpotLight(const Proc_SpotLight& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Proc_SpotLight* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.pos_){nullptr}
    , decltype(_impl_.color_){nullptr}
    , decltype(_impl_.atenuation_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_pos()) {
    _this->_impl_.pos_ = new ::Proc_Vec2(*from._impl_.pos_);
  }
  if (from._internal_has_color()) {
    _this->_impl_.color_ = new ::Proc_Vec4(*from._impl_.color_);
  }
  if (from._internal_has_atenuation()) {
    _this->_impl_.atenuation_ = new ::Proc_Vec3(*from._impl_.atenuation_);
  }
  // @@protoc_insertion_point(copy_constructor:Proc_SpotLight)
}

inline void Proc_SpotLight::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.pos_){nullptr}
    , decltype(_impl_.color_){nullptr}
    , decltype(_impl_.atenuation_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Proc_SpotLight::~Proc_SpotLight() {
  // @@protoc_insertion_point(destructor:Proc_SpotLight)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Proc_SpotLight::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.pos_;
  if (this != internal_default_instance()) delete _impl_.color_;
  if (this != internal_default_instance()) delete _impl_.atenuation_;
}

void Proc_SpotLight::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Proc_SpotLight::Clear() {
// @@protoc_insertion_point(message_clear_start:Proc_SpotLight)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.pos_ != nullptr) {
    delete _impl_.pos_;
  }
  _impl_.pos_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.color_ != nullptr) {
    delete _impl_.color_;
  }
  _impl_.color_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.atenuation_ != nullptr) {
    delete _impl_.atenuation_;
  }
  _impl_.atenuation_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Proc_SpotLight::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .Proc_Vec2 pos = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_pos(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Proc_Vec4 color = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_color(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Proc_Vec3 atenuation = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_atenuation(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Proc_SpotLight::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Proc_SpotLight)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .Proc_Vec2 pos = 1;
  if (this->_internal_has_pos()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::pos(this),
        _Internal::pos(this).GetCachedSize(), target, stream);
  }

  // .Proc_Vec4 color = 2;
  if (this->_internal_has_color()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::color(this),
        _Internal::color(this).GetCachedSize(), target, stream);
  }

  // .Proc_Vec3 atenuation = 3;
  if (this->_internal_has_atenuation()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::atenuation(this),
        _Internal::atenuation(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Proc_SpotLight)
  return target;
}

size_t Proc_SpotLight::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Proc_SpotLight)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .Proc_Vec2 pos = 1;
  if (this->_internal_has_pos()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.pos_);
  }

  // .Proc_Vec4 color = 2;
  if (this->_internal_has_color()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.color_);
  }

  // .Proc_Vec3 atenuation = 3;
  if (this->_internal_has_atenuation()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.atenuation_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Proc_SpotLight::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Proc_SpotLight::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Proc_SpotLight::GetClassData() const { return &_class_data_; }


void Proc_SpotLight::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Proc_SpotLight*>(&to_msg);
  auto& from = static_cast<const Proc_SpotLight&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Proc_SpotLight)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_pos()) {
    _this->_internal_mutable_pos()->::Proc_Vec2::MergeFrom(
        from._internal_pos());
  }
  if (from._internal_has_color()) {
    _this->_internal_mutable_color()->::Proc_Vec4::MergeFrom(
        from._internal_color());
  }
  if (from._internal_has_atenuation()) {
    _this->_internal_mutable_atenuation()->::Proc_Vec3::MergeFrom(
        from._internal_atenuation());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Proc_SpotLight::CopyFrom(const Proc_SpotLight& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Proc_SpotLight)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Proc_SpotLight::IsInitialized() const {
  return true;
}

void Proc_SpotLight::InternalSwap(Proc_SpotLight* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Proc_SpotLight, _impl_.atenuation_)
      + sizeof(Proc_SpotLight::_impl_.atenuation_)
      - PROTOBUF_FIELD_OFFSET(Proc_SpotLight, _impl_.pos_)>(
          reinterpret_cast<char*>(&_impl_.pos_),
          reinterpret_cast<char*>(&other->_impl_.pos_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Proc_SpotLight::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_F_5fScreen_2eproto_getter, &descriptor_table_F_5fScreen_2eproto_once,
      file_level_metadata_F_5fScreen_2eproto[3]);
}

// ===================================================================

class Proc_ColiderBox::_Internal {
 public:
  static const ::Proc_Vec2& pos(const Proc_ColiderBox* msg);
  static const ::Proc_Vec2& dim(const Proc_ColiderBox* msg);
};

const ::Proc_Vec2&
Proc_ColiderBox::_Internal::pos(const Proc_ColiderBox* msg) {
  return *msg->_impl_.pos_;
}
const ::Proc_Vec2&
Proc_ColiderBox::_Internal::dim(const Proc_ColiderBox* msg) {
  return *msg->_impl_.dim_;
}
Proc_ColiderBox::Proc_ColiderBox(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Proc_ColiderBox)
}
Proc_ColiderBox::Proc_ColiderBox(const Proc_ColiderBox& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Proc_ColiderBox* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.pos_){nullptr}
    , decltype(_impl_.dim_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_pos()) {
    _this->_impl_.pos_ = new ::Proc_Vec2(*from._impl_.pos_);
  }
  if (from._internal_has_dim()) {
    _this->_impl_.dim_ = new ::Proc_Vec2(*from._impl_.dim_);
  }
  // @@protoc_insertion_point(copy_constructor:Proc_ColiderBox)
}

inline void Proc_ColiderBox::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.pos_){nullptr}
    , decltype(_impl_.dim_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Proc_ColiderBox::~Proc_ColiderBox() {
  // @@protoc_insertion_point(destructor:Proc_ColiderBox)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Proc_ColiderBox::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.pos_;
  if (this != internal_default_instance()) delete _impl_.dim_;
}

void Proc_ColiderBox::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Proc_ColiderBox::Clear() {
// @@protoc_insertion_point(message_clear_start:Proc_ColiderBox)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.pos_ != nullptr) {
    delete _impl_.pos_;
  }
  _impl_.pos_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.dim_ != nullptr) {
    delete _impl_.dim_;
  }
  _impl_.dim_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Proc_ColiderBox::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .Proc_Vec2 pos = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_pos(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Proc_Vec2 dim = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_dim(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Proc_ColiderBox::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Proc_ColiderBox)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .Proc_Vec2 pos = 1;
  if (this->_internal_has_pos()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::pos(this),
        _Internal::pos(this).GetCachedSize(), target, stream);
  }

  // .Proc_Vec2 dim = 2;
  if (this->_internal_has_dim()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::dim(this),
        _Internal::dim(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Proc_ColiderBox)
  return target;
}

size_t Proc_ColiderBox::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Proc_ColiderBox)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .Proc_Vec2 pos = 1;
  if (this->_internal_has_pos()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.pos_);
  }

  // .Proc_Vec2 dim = 2;
  if (this->_internal_has_dim()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.dim_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Proc_ColiderBox::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Proc_ColiderBox::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Proc_ColiderBox::GetClassData() const { return &_class_data_; }


void Proc_ColiderBox::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Proc_ColiderBox*>(&to_msg);
  auto& from = static_cast<const Proc_ColiderBox&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Proc_ColiderBox)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_pos()) {
    _this->_internal_mutable_pos()->::Proc_Vec2::MergeFrom(
        from._internal_pos());
  }
  if (from._internal_has_dim()) {
    _this->_internal_mutable_dim()->::Proc_Vec2::MergeFrom(
        from._internal_dim());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Proc_ColiderBox::CopyFrom(const Proc_ColiderBox& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Proc_ColiderBox)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Proc_ColiderBox::IsInitialized() const {
  return true;
}

void Proc_ColiderBox::InternalSwap(Proc_ColiderBox* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Proc_ColiderBox, _impl_.dim_)
      + sizeof(Proc_ColiderBox::_impl_.dim_)
      - PROTOBUF_FIELD_OFFSET(Proc_ColiderBox, _impl_.pos_)>(
          reinterpret_cast<char*>(&_impl_.pos_),
          reinterpret_cast<char*>(&other->_impl_.pos_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Proc_ColiderBox::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_F_5fScreen_2eproto_getter, &descriptor_table_F_5fScreen_2eproto_once,
      file_level_metadata_F_5fScreen_2eproto[4]);
}

// ===================================================================

class Proc_Sprite::_Internal {
 public:
  static const ::Proc_Vec2& dim(const Proc_Sprite* msg);
};

const ::Proc_Vec2&
Proc_Sprite::_Internal::dim(const Proc_Sprite* msg) {
  return *msg->_impl_.dim_;
}
Proc_Sprite::Proc_Sprite(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Proc_Sprite)
}
Proc_Sprite::Proc_Sprite(const Proc_Sprite& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Proc_Sprite* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.texturepath_){}
    , decltype(_impl_.name_){}
    , decltype(_impl_.packetname_){}
    , decltype(_impl_.dim_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.texturepath_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.texturepath_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_texturepath().empty()) {
    _this->_impl_.texturepath_.Set(from._internal_texturepath(), 
      _this->GetArenaForAllocation());
  }
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.packetname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.packetname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_packetname().empty()) {
    _this->_impl_.packetname_.Set(from._internal_packetname(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_dim()) {
    _this->_impl_.dim_ = new ::Proc_Vec2(*from._impl_.dim_);
  }
  // @@protoc_insertion_point(copy_constructor:Proc_Sprite)
}

inline void Proc_Sprite::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.texturepath_){}
    , decltype(_impl_.name_){}
    , decltype(_impl_.packetname_){}
    , decltype(_impl_.dim_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.texturepath_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.texturepath_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.packetname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.packetname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Proc_Sprite::~Proc_Sprite() {
  // @@protoc_insertion_point(destructor:Proc_Sprite)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Proc_Sprite::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.texturepath_.Destroy();
  _impl_.name_.Destroy();
  _impl_.packetname_.Destroy();
  if (this != internal_default_instance()) delete _impl_.dim_;
}

void Proc_Sprite::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Proc_Sprite::Clear() {
// @@protoc_insertion_point(message_clear_start:Proc_Sprite)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.texturepath_.ClearToEmpty();
  _impl_.name_.ClearToEmpty();
  _impl_.packetname_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.dim_ != nullptr) {
    delete _impl_.dim_;
  }
  _impl_.dim_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Proc_Sprite::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string texturePath = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_texturepath();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "Proc_Sprite.texturePath"));
        } else
          goto handle_unusual;
        continue;
      // .Proc_Vec2 dim = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_dim(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "Proc_Sprite.name"));
        } else
          goto handle_unusual;
        continue;
      // string packetName = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_packetname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "Proc_Sprite.packetName"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Proc_Sprite::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Proc_Sprite)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string texturePath = 1;
  if (!this->_internal_texturepath().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_texturepath().data(), static_cast<int>(this->_internal_texturepath().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Proc_Sprite.texturePath");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_texturepath(), target);
  }

  // .Proc_Vec2 dim = 2;
  if (this->_internal_has_dim()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::dim(this),
        _Internal::dim(this).GetCachedSize(), target, stream);
  }

  // string name = 3;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Proc_Sprite.name");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_name(), target);
  }

  // string packetName = 4;
  if (!this->_internal_packetname().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_packetname().data(), static_cast<int>(this->_internal_packetname().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Proc_Sprite.packetName");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_packetname(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Proc_Sprite)
  return target;
}

size_t Proc_Sprite::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Proc_Sprite)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string texturePath = 1;
  if (!this->_internal_texturepath().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_texturepath());
  }

  // string name = 3;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // string packetName = 4;
  if (!this->_internal_packetname().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_packetname());
  }

  // .Proc_Vec2 dim = 2;
  if (this->_internal_has_dim()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.dim_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Proc_Sprite::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Proc_Sprite::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Proc_Sprite::GetClassData() const { return &_class_data_; }


void Proc_Sprite::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Proc_Sprite*>(&to_msg);
  auto& from = static_cast<const Proc_Sprite&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Proc_Sprite)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_texturepath().empty()) {
    _this->_internal_set_texturepath(from._internal_texturepath());
  }
  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (!from._internal_packetname().empty()) {
    _this->_internal_set_packetname(from._internal_packetname());
  }
  if (from._internal_has_dim()) {
    _this->_internal_mutable_dim()->::Proc_Vec2::MergeFrom(
        from._internal_dim());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Proc_Sprite::CopyFrom(const Proc_Sprite& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Proc_Sprite)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Proc_Sprite::IsInitialized() const {
  return true;
}

void Proc_Sprite::InternalSwap(Proc_Sprite* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.texturepath_, lhs_arena,
      &other->_impl_.texturepath_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.packetname_, lhs_arena,
      &other->_impl_.packetname_, rhs_arena
  );
  swap(_impl_.dim_, other->_impl_.dim_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Proc_Sprite::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_F_5fScreen_2eproto_getter, &descriptor_table_F_5fScreen_2eproto_once,
      file_level_metadata_F_5fScreen_2eproto[5]);
}

// ===================================================================

class Proc_OwnSprite::_Internal {
 public:
  using HasBits = decltype(std::declval<Proc_OwnSprite>()._impl_._has_bits_);
  static const ::Proc_Sprite& proc_sprite(const Proc_OwnSprite* msg);
  static const ::Proc_Vec2& offsetpos(const Proc_OwnSprite* msg);
  static const ::Proc_Vec2& offsetscale(const Proc_OwnSprite* msg);
  static const ::Proc_Vec4& color(const Proc_OwnSprite* msg);
  static void set_has_angle(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::Proc_Sprite&
Proc_OwnSprite::_Internal::proc_sprite(const Proc_OwnSprite* msg) {
  return *msg->_impl_.proc_sprite_;
}
const ::Proc_Vec2&
Proc_OwnSprite::_Internal::offsetpos(const Proc_OwnSprite* msg) {
  return *msg->_impl_.offsetpos_;
}
const ::Proc_Vec2&
Proc_OwnSprite::_Internal::offsetscale(const Proc_OwnSprite* msg) {
  return *msg->_impl_.offsetscale_;
}
const ::Proc_Vec4&
Proc_OwnSprite::_Internal::color(const Proc_OwnSprite* msg) {
  return *msg->_impl_.color_;
}
Proc_OwnSprite::Proc_OwnSprite(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Proc_OwnSprite)
}
Proc_OwnSprite::Proc_OwnSprite(const Proc_OwnSprite& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Proc_OwnSprite* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.proc_sprite_){nullptr}
    , decltype(_impl_.offsetpos_){nullptr}
    , decltype(_impl_.offsetscale_){nullptr}
    , decltype(_impl_.color_){nullptr}
    , decltype(_impl_.depth_){}
    , decltype(_impl_.angle_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_proc_sprite()) {
    _this->_impl_.proc_sprite_ = new ::Proc_Sprite(*from._impl_.proc_sprite_);
  }
  if (from._internal_has_offsetpos()) {
    _this->_impl_.offsetpos_ = new ::Proc_Vec2(*from._impl_.offsetpos_);
  }
  if (from._internal_has_offsetscale()) {
    _this->_impl_.offsetscale_ = new ::Proc_Vec2(*from._impl_.offsetscale_);
  }
  if (from._internal_has_color()) {
    _this->_impl_.color_ = new ::Proc_Vec4(*from._impl_.color_);
  }
  ::memcpy(&_impl_.depth_, &from._impl_.depth_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.angle_) -
    reinterpret_cast<char*>(&_impl_.depth_)) + sizeof(_impl_.angle_));
  // @@protoc_insertion_point(copy_constructor:Proc_OwnSprite)
}

inline void Proc_OwnSprite::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.proc_sprite_){nullptr}
    , decltype(_impl_.offsetpos_){nullptr}
    , decltype(_impl_.offsetscale_){nullptr}
    , decltype(_impl_.color_){nullptr}
    , decltype(_impl_.depth_){0}
    , decltype(_impl_.angle_){0}
  };
}

Proc_OwnSprite::~Proc_OwnSprite() {
  // @@protoc_insertion_point(destructor:Proc_OwnSprite)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Proc_OwnSprite::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.proc_sprite_;
  if (this != internal_default_instance()) delete _impl_.offsetpos_;
  if (this != internal_default_instance()) delete _impl_.offsetscale_;
  if (this != internal_default_instance()) delete _impl_.color_;
}

void Proc_OwnSprite::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Proc_OwnSprite::Clear() {
// @@protoc_insertion_point(message_clear_start:Proc_OwnSprite)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.proc_sprite_ != nullptr) {
    delete _impl_.proc_sprite_;
  }
  _impl_.proc_sprite_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.offsetpos_ != nullptr) {
    delete _impl_.offsetpos_;
  }
  _impl_.offsetpos_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.offsetscale_ != nullptr) {
    delete _impl_.offsetscale_;
  }
  _impl_.offsetscale_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.color_ != nullptr) {
    delete _impl_.color_;
  }
  _impl_.color_ = nullptr;
  _impl_.depth_ = 0;
  _impl_.angle_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Proc_OwnSprite::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .Proc_Sprite Proc_Sprite = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_proc_sprite(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Proc_Vec2 offsetPos = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_offsetpos(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Proc_Vec2 offsetScale = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_offsetscale(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Proc_Vec4 color = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_color(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // float depth = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _impl_.depth_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float angle = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 53)) {
          _Internal::set_has_angle(&has_bits);
          _impl_.angle_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Proc_OwnSprite::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Proc_OwnSprite)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .Proc_Sprite Proc_Sprite = 1;
  if (this->_internal_has_proc_sprite()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::proc_sprite(this),
        _Internal::proc_sprite(this).GetCachedSize(), target, stream);
  }

  // .Proc_Vec2 offsetPos = 2;
  if (this->_internal_has_offsetpos()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::offsetpos(this),
        _Internal::offsetpos(this).GetCachedSize(), target, stream);
  }

  // .Proc_Vec2 offsetScale = 3;
  if (this->_internal_has_offsetscale()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::offsetscale(this),
        _Internal::offsetscale(this).GetCachedSize(), target, stream);
  }

  // .Proc_Vec4 color = 4;
  if (this->_internal_has_color()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::color(this),
        _Internal::color(this).GetCachedSize(), target, stream);
  }

  // float depth = 5;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_depth = this->_internal_depth();
  uint32_t raw_depth;
  memcpy(&raw_depth, &tmp_depth, sizeof(tmp_depth));
  if (raw_depth != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(5, this->_internal_depth(), target);
  }

  // optional float angle = 6;
  if (_internal_has_angle()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(6, this->_internal_angle(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Proc_OwnSprite)
  return target;
}

size_t Proc_OwnSprite::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Proc_OwnSprite)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .Proc_Sprite Proc_Sprite = 1;
  if (this->_internal_has_proc_sprite()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.proc_sprite_);
  }

  // .Proc_Vec2 offsetPos = 2;
  if (this->_internal_has_offsetpos()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.offsetpos_);
  }

  // .Proc_Vec2 offsetScale = 3;
  if (this->_internal_has_offsetscale()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.offsetscale_);
  }

  // .Proc_Vec4 color = 4;
  if (this->_internal_has_color()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.color_);
  }

  // float depth = 5;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_depth = this->_internal_depth();
  uint32_t raw_depth;
  memcpy(&raw_depth, &tmp_depth, sizeof(tmp_depth));
  if (raw_depth != 0) {
    total_size += 1 + 4;
  }

  // optional float angle = 6;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Proc_OwnSprite::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Proc_OwnSprite::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Proc_OwnSprite::GetClassData() const { return &_class_data_; }


void Proc_OwnSprite::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Proc_OwnSprite*>(&to_msg);
  auto& from = static_cast<const Proc_OwnSprite&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Proc_OwnSprite)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_proc_sprite()) {
    _this->_internal_mutable_proc_sprite()->::Proc_Sprite::MergeFrom(
        from._internal_proc_sprite());
  }
  if (from._internal_has_offsetpos()) {
    _this->_internal_mutable_offsetpos()->::Proc_Vec2::MergeFrom(
        from._internal_offsetpos());
  }
  if (from._internal_has_offsetscale()) {
    _this->_internal_mutable_offsetscale()->::Proc_Vec2::MergeFrom(
        from._internal_offsetscale());
  }
  if (from._internal_has_color()) {
    _this->_internal_mutable_color()->::Proc_Vec4::MergeFrom(
        from._internal_color());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_depth = from._internal_depth();
  uint32_t raw_depth;
  memcpy(&raw_depth, &tmp_depth, sizeof(tmp_depth));
  if (raw_depth != 0) {
    _this->_internal_set_depth(from._internal_depth());
  }
  if (from._internal_has_angle()) {
    _this->_internal_set_angle(from._internal_angle());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Proc_OwnSprite::CopyFrom(const Proc_OwnSprite& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Proc_OwnSprite)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Proc_OwnSprite::IsInitialized() const {
  return true;
}

void Proc_OwnSprite::InternalSwap(Proc_OwnSprite* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Proc_OwnSprite, _impl_.angle_)
      + sizeof(Proc_OwnSprite::_impl_.angle_)
      - PROTOBUF_FIELD_OFFSET(Proc_OwnSprite, _impl_.proc_sprite_)>(
          reinterpret_cast<char*>(&_impl_.proc_sprite_),
          reinterpret_cast<char*>(&other->_impl_.proc_sprite_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Proc_OwnSprite::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_F_5fScreen_2eproto_getter, &descriptor_table_F_5fScreen_2eproto_once,
      file_level_metadata_F_5fScreen_2eproto[6]);
}

// ===================================================================

class Proc_Object::_Internal {
 public:
};

Proc_Object::Proc_Object(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Proc_Object)
}
Proc_Object::Proc_Object(const Proc_Object& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Proc_Object* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.proc_spritelist_){from._impl_.proc_spritelist_}
    , decltype(_impl_.lightlist_){from._impl_.lightlist_}
    , decltype(_impl_.coliderlist_){from._impl_.coliderlist_}
    , decltype(_impl_.name_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:Proc_Object)
}

inline void Proc_Object::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.proc_spritelist_){arena}
    , decltype(_impl_.lightlist_){arena}
    , decltype(_impl_.coliderlist_){arena}
    , decltype(_impl_.name_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Proc_Object::~Proc_Object() {
  // @@protoc_insertion_point(destructor:Proc_Object)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Proc_Object::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.proc_spritelist_.~RepeatedPtrField();
  _impl_.lightlist_.~RepeatedPtrField();
  _impl_.coliderlist_.~RepeatedPtrField();
  _impl_.name_.Destroy();
}

void Proc_Object::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Proc_Object::Clear() {
// @@protoc_insertion_point(message_clear_start:Proc_Object)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.proc_spritelist_.Clear();
  _impl_.lightlist_.Clear();
  _impl_.coliderlist_.Clear();
  _impl_.name_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Proc_Object::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "Proc_Object.name"));
        } else
          goto handle_unusual;
        continue;
      // repeated .Proc_OwnSprite Proc_SpriteList = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_proc_spritelist(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .Proc_SpotLight lightList = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_lightlist(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .Proc_ColiderBox coliderList = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_coliderlist(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Proc_Object::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Proc_Object)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Proc_Object.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // repeated .Proc_OwnSprite Proc_SpriteList = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_proc_spritelist_size()); i < n; i++) {
    const auto& repfield = this->_internal_proc_spritelist(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .Proc_SpotLight lightList = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_lightlist_size()); i < n; i++) {
    const auto& repfield = this->_internal_lightlist(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .Proc_ColiderBox coliderList = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_coliderlist_size()); i < n; i++) {
    const auto& repfield = this->_internal_coliderlist(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Proc_Object)
  return target;
}

size_t Proc_Object::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Proc_Object)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .Proc_OwnSprite Proc_SpriteList = 2;
  total_size += 1UL * this->_internal_proc_spritelist_size();
  for (const auto& msg : this->_impl_.proc_spritelist_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .Proc_SpotLight lightList = 3;
  total_size += 1UL * this->_internal_lightlist_size();
  for (const auto& msg : this->_impl_.lightlist_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .Proc_ColiderBox coliderList = 4;
  total_size += 1UL * this->_internal_coliderlist_size();
  for (const auto& msg : this->_impl_.coliderlist_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Proc_Object::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Proc_Object::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Proc_Object::GetClassData() const { return &_class_data_; }


void Proc_Object::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Proc_Object*>(&to_msg);
  auto& from = static_cast<const Proc_Object&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Proc_Object)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.proc_spritelist_.MergeFrom(from._impl_.proc_spritelist_);
  _this->_impl_.lightlist_.MergeFrom(from._impl_.lightlist_);
  _this->_impl_.coliderlist_.MergeFrom(from._impl_.coliderlist_);
  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Proc_Object::CopyFrom(const Proc_Object& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Proc_Object)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Proc_Object::IsInitialized() const {
  return true;
}

void Proc_Object::InternalSwap(Proc_Object* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.proc_spritelist_.InternalSwap(&other->_impl_.proc_spritelist_);
  _impl_.lightlist_.InternalSwap(&other->_impl_.lightlist_);
  _impl_.coliderlist_.InternalSwap(&other->_impl_.coliderlist_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata Proc_Object::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_F_5fScreen_2eproto_getter, &descriptor_table_F_5fScreen_2eproto_once,
      file_level_metadata_F_5fScreen_2eproto[7]);
}

// @@protoc_insertion_point(namespace_scope)
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::Proc_Vec2*
Arena::CreateMaybeMessage< ::Proc_Vec2 >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Proc_Vec2 >(arena);
}
template<> PROTOBUF_NOINLINE ::Proc_Vec3*
Arena::CreateMaybeMessage< ::Proc_Vec3 >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Proc_Vec3 >(arena);
}
template<> PROTOBUF_NOINLINE ::Proc_Vec4*
Arena::CreateMaybeMessage< ::Proc_Vec4 >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Proc_Vec4 >(arena);
}
template<> PROTOBUF_NOINLINE ::Proc_SpotLight*
Arena::CreateMaybeMessage< ::Proc_SpotLight >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Proc_SpotLight >(arena);
}
template<> PROTOBUF_NOINLINE ::Proc_ColiderBox*
Arena::CreateMaybeMessage< ::Proc_ColiderBox >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Proc_ColiderBox >(arena);
}
template<> PROTOBUF_NOINLINE ::Proc_Sprite*
Arena::CreateMaybeMessage< ::Proc_Sprite >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Proc_Sprite >(arena);
}
template<> PROTOBUF_NOINLINE ::Proc_OwnSprite*
Arena::CreateMaybeMessage< ::Proc_OwnSprite >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Proc_OwnSprite >(arena);
}
template<> PROTOBUF_NOINLINE ::Proc_Object*
Arena::CreateMaybeMessage< ::Proc_Object >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Proc_Object >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
