// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: serverData.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_serverData_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_serverData_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021002 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_serverData_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_serverData_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_serverData_2eproto;
class CharacterLog;
struct CharacterLogDefaultTypeInternal;
extern CharacterLogDefaultTypeInternal _CharacterLog_default_instance_;
class ClientCommand;
struct ClientCommandDefaultTypeInternal;
extern ClientCommandDefaultTypeInternal _ClientCommand_default_instance_;
class Error;
struct ErrorDefaultTypeInternal;
extern ErrorDefaultTypeInternal _Error_default_instance_;
class LogList;
struct LogListDefaultTypeInternal;
extern LogListDefaultTypeInternal _LogList_default_instance_;
class Login;
struct LoginDefaultTypeInternal;
extern LoginDefaultTypeInternal _Login_default_instance_;
class Login_Info;
struct Login_InfoDefaultTypeInternal;
extern Login_InfoDefaultTypeInternal _Login_Info_default_instance_;
class PlayerMSG;
struct PlayerMSGDefaultTypeInternal;
extern PlayerMSGDefaultTypeInternal _PlayerMSG_default_instance_;
class PlayerState;
struct PlayerStateDefaultTypeInternal;
extern PlayerStateDefaultTypeInternal _PlayerState_default_instance_;
class Register;
struct RegisterDefaultTypeInternal;
extern RegisterDefaultTypeInternal _Register_default_instance_;
class TCP_msg;
struct TCP_msgDefaultTypeInternal;
extern TCP_msgDefaultTypeInternal _TCP_msg_default_instance_;
class UDP_msg;
struct UDP_msgDefaultTypeInternal;
extern UDP_msgDefaultTypeInternal _UDP_msg_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::CharacterLog* Arena::CreateMaybeMessage<::CharacterLog>(Arena*);
template<> ::ClientCommand* Arena::CreateMaybeMessage<::ClientCommand>(Arena*);
template<> ::Error* Arena::CreateMaybeMessage<::Error>(Arena*);
template<> ::LogList* Arena::CreateMaybeMessage<::LogList>(Arena*);
template<> ::Login* Arena::CreateMaybeMessage<::Login>(Arena*);
template<> ::Login_Info* Arena::CreateMaybeMessage<::Login_Info>(Arena*);
template<> ::PlayerMSG* Arena::CreateMaybeMessage<::PlayerMSG>(Arena*);
template<> ::PlayerState* Arena::CreateMaybeMessage<::PlayerState>(Arena*);
template<> ::Register* Arena::CreateMaybeMessage<::Register>(Arena*);
template<> ::TCP_msg* Arena::CreateMaybeMessage<::TCP_msg>(Arena*);
template<> ::UDP_msg* Arena::CreateMaybeMessage<::UDP_msg>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

// ===================================================================

class Login final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Login) */ {
 public:
  inline Login() : Login(nullptr) {}
  ~Login() override;
  explicit PROTOBUF_CONSTEXPR Login(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Login(const Login& from);
  Login(Login&& from) noexcept
    : Login() {
    *this = ::std::move(from);
  }

  inline Login& operator=(const Login& from) {
    CopyFrom(from);
    return *this;
  }
  inline Login& operator=(Login&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Login& default_instance() {
    return *internal_default_instance();
  }
  static inline const Login* internal_default_instance() {
    return reinterpret_cast<const Login*>(
               &_Login_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Login& a, Login& b) {
    a.Swap(&b);
  }
  inline void Swap(Login* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Login* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Login* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Login>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Login& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Login& from) {
    Login::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Login* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Login";
  }
  protected:
  explicit Login(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIDFieldNumber = 1,
    kPasswordFieldNumber = 2,
  };
  // string ID = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string password = 2;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // @@protoc_insertion_point(class_scope:Login)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_serverData_2eproto;
};
// -------------------------------------------------------------------

class Register final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Register) */ {
 public:
  inline Register() : Register(nullptr) {}
  ~Register() override;
  explicit PROTOBUF_CONSTEXPR Register(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Register(const Register& from);
  Register(Register&& from) noexcept
    : Register() {
    *this = ::std::move(from);
  }

  inline Register& operator=(const Register& from) {
    CopyFrom(from);
    return *this;
  }
  inline Register& operator=(Register&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Register& default_instance() {
    return *internal_default_instance();
  }
  static inline const Register* internal_default_instance() {
    return reinterpret_cast<const Register*>(
               &_Register_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Register& a, Register& b) {
    a.Swap(&b);
  }
  inline void Swap(Register* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Register* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Register* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Register>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Register& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Register& from) {
    Register::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Register* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Register";
  }
  protected:
  explicit Register(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIDFieldNumber = 1,
    kPasswordFieldNumber = 2,
  };
  // string ID = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string password = 2;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // @@protoc_insertion_point(class_scope:Register)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_serverData_2eproto;
};
// -------------------------------------------------------------------

class PlayerMSG final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PlayerMSG) */ {
 public:
  inline PlayerMSG() : PlayerMSG(nullptr) {}
  ~PlayerMSG() override;
  explicit PROTOBUF_CONSTEXPR PlayerMSG(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlayerMSG(const PlayerMSG& from);
  PlayerMSG(PlayerMSG&& from) noexcept
    : PlayerMSG() {
    *this = ::std::move(from);
  }

  inline PlayerMSG& operator=(const PlayerMSG& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerMSG& operator=(PlayerMSG&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerMSG& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerMSG* internal_default_instance() {
    return reinterpret_cast<const PlayerMSG*>(
               &_PlayerMSG_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(PlayerMSG& a, PlayerMSG& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerMSG* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerMSG* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerMSG* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlayerMSG>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlayerMSG& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PlayerMSG& from) {
    PlayerMSG::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerMSG* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PlayerMSG";
  }
  protected:
  explicit PlayerMSG(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 1,
  };
  // string msg = 1;
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // @@protoc_insertion_point(class_scope:PlayerMSG)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_serverData_2eproto;
};
// -------------------------------------------------------------------

class CharacterLog final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CharacterLog) */ {
 public:
  inline CharacterLog() : CharacterLog(nullptr) {}
  ~CharacterLog() override;
  explicit PROTOBUF_CONSTEXPR CharacterLog(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CharacterLog(const CharacterLog& from);
  CharacterLog(CharacterLog&& from) noexcept
    : CharacterLog() {
    *this = ::std::move(from);
  }

  inline CharacterLog& operator=(const CharacterLog& from) {
    CopyFrom(from);
    return *this;
  }
  inline CharacterLog& operator=(CharacterLog&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CharacterLog& default_instance() {
    return *internal_default_instance();
  }
  static inline const CharacterLog* internal_default_instance() {
    return reinterpret_cast<const CharacterLog*>(
               &_CharacterLog_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(CharacterLog& a, CharacterLog& b) {
    a.Swap(&b);
  }
  inline void Swap(CharacterLog* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CharacterLog* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CharacterLog* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CharacterLog>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CharacterLog& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CharacterLog& from) {
    CharacterLog::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CharacterLog* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CharacterLog";
  }
  protected:
  explicit CharacterLog(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kLocationFieldNumber = 2,
    kXPosFieldNumber = 3,
    kYPosFieldNumber = 4,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string location = 2;
  void clear_location();
  const std::string& location() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_location(ArgT0&& arg0, ArgT... args);
  std::string* mutable_location();
  PROTOBUF_NODISCARD std::string* release_location();
  void set_allocated_location(std::string* location);
  private:
  const std::string& _internal_location() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_location(const std::string& value);
  std::string* _internal_mutable_location();
  public:

  // float x_pos = 3;
  void clear_x_pos();
  float x_pos() const;
  void set_x_pos(float value);
  private:
  float _internal_x_pos() const;
  void _internal_set_x_pos(float value);
  public:

  // float y_pos = 4;
  void clear_y_pos();
  float y_pos() const;
  void set_y_pos(float value);
  private:
  float _internal_y_pos() const;
  void _internal_set_y_pos(float value);
  public:

  // @@protoc_insertion_point(class_scope:CharacterLog)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr location_;
    float x_pos_;
    float y_pos_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_serverData_2eproto;
};
// -------------------------------------------------------------------

class LogList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:LogList) */ {
 public:
  inline LogList() : LogList(nullptr) {}
  ~LogList() override;
  explicit PROTOBUF_CONSTEXPR LogList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LogList(const LogList& from);
  LogList(LogList&& from) noexcept
    : LogList() {
    *this = ::std::move(from);
  }

  inline LogList& operator=(const LogList& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogList& operator=(LogList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LogList& default_instance() {
    return *internal_default_instance();
  }
  static inline const LogList* internal_default_instance() {
    return reinterpret_cast<const LogList*>(
               &_LogList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(LogList& a, LogList& b) {
    a.Swap(&b);
  }
  inline void Swap(LogList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LogList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LogList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LogList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LogList& from) {
    LogList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "LogList";
  }
  protected:
  explicit LogList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kListFieldNumber = 1,
  };
  // repeated .CharacterLog list = 1;
  int list_size() const;
  private:
  int _internal_list_size() const;
  public:
  void clear_list();
  ::CharacterLog* mutable_list(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CharacterLog >*
      mutable_list();
  private:
  const ::CharacterLog& _internal_list(int index) const;
  ::CharacterLog* _internal_add_list();
  public:
  const ::CharacterLog& list(int index) const;
  ::CharacterLog* add_list();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CharacterLog >&
      list() const;

  // @@protoc_insertion_point(class_scope:LogList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CharacterLog > list_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_serverData_2eproto;
};
// -------------------------------------------------------------------

class PlayerState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PlayerState) */ {
 public:
  inline PlayerState() : PlayerState(nullptr) {}
  ~PlayerState() override;
  explicit PROTOBUF_CONSTEXPR PlayerState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlayerState(const PlayerState& from);
  PlayerState(PlayerState&& from) noexcept
    : PlayerState() {
    *this = ::std::move(from);
  }

  inline PlayerState& operator=(const PlayerState& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerState& operator=(PlayerState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerState& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerState* internal_default_instance() {
    return reinterpret_cast<const PlayerState*>(
               &_PlayerState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(PlayerState& a, PlayerState& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlayerState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlayerState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PlayerState& from) {
    PlayerState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PlayerState";
  }
  protected:
  explicit PlayerState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kActionFieldNumber = 2,
    kXPosFieldNumber = 3,
    kYPosFieldNumber = 4,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // int32 action = 2;
  void clear_action();
  int32_t action() const;
  void set_action(int32_t value);
  private:
  int32_t _internal_action() const;
  void _internal_set_action(int32_t value);
  public:

  // float x_pos = 3;
  void clear_x_pos();
  float x_pos() const;
  void set_x_pos(float value);
  private:
  float _internal_x_pos() const;
  void _internal_set_x_pos(float value);
  public:

  // float y_pos = 4;
  void clear_y_pos();
  float y_pos() const;
  void set_y_pos(float value);
  private:
  float _internal_y_pos() const;
  void _internal_set_y_pos(float value);
  public:

  // @@protoc_insertion_point(class_scope:PlayerState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    int32_t action_;
    float x_pos_;
    float y_pos_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_serverData_2eproto;
};
// -------------------------------------------------------------------

class Login_Info final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Login_Info) */ {
 public:
  inline Login_Info() : Login_Info(nullptr) {}
  ~Login_Info() override;
  explicit PROTOBUF_CONSTEXPR Login_Info(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Login_Info(const Login_Info& from);
  Login_Info(Login_Info&& from) noexcept
    : Login_Info() {
    *this = ::std::move(from);
  }

  inline Login_Info& operator=(const Login_Info& from) {
    CopyFrom(from);
    return *this;
  }
  inline Login_Info& operator=(Login_Info&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Login_Info& default_instance() {
    return *internal_default_instance();
  }
  static inline const Login_Info* internal_default_instance() {
    return reinterpret_cast<const Login_Info*>(
               &_Login_Info_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Login_Info& a, Login_Info& b) {
    a.Swap(&b);
  }
  inline void Swap(Login_Info* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Login_Info* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Login_Info* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Login_Info>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Login_Info& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Login_Info& from) {
    Login_Info::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Login_Info* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Login_Info";
  }
  protected:
  explicit Login_Info(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIDFieldNumber = 1,
  };
  // string ID = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:Login_Info)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_serverData_2eproto;
};
// -------------------------------------------------------------------

class ClientCommand final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ClientCommand) */ {
 public:
  inline ClientCommand() : ClientCommand(nullptr) {}
  ~ClientCommand() override;
  explicit PROTOBUF_CONSTEXPR ClientCommand(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClientCommand(const ClientCommand& from);
  ClientCommand(ClientCommand&& from) noexcept
    : ClientCommand() {
    *this = ::std::move(from);
  }

  inline ClientCommand& operator=(const ClientCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientCommand& operator=(ClientCommand&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClientCommand& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClientCommand* internal_default_instance() {
    return reinterpret_cast<const ClientCommand*>(
               &_ClientCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ClientCommand& a, ClientCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(ClientCommand* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientCommand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClientCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClientCommand>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ClientCommand& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ClientCommand& from) {
    ClientCommand::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientCommand* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ClientCommand";
  }
  protected:
  explicit ClientCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCommandFieldNumber = 1,
  };
  // string command = 1;
  void clear_command();
  const std::string& command() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_command(ArgT0&& arg0, ArgT... args);
  std::string* mutable_command();
  PROTOBUF_NODISCARD std::string* release_command();
  void set_allocated_command(std::string* command);
  private:
  const std::string& _internal_command() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_command(const std::string& value);
  std::string* _internal_mutable_command();
  public:

  // @@protoc_insertion_point(class_scope:ClientCommand)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr command_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_serverData_2eproto;
};
// -------------------------------------------------------------------

class Error final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Error) */ {
 public:
  inline Error() : Error(nullptr) {}
  ~Error() override;
  explicit PROTOBUF_CONSTEXPR Error(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Error(const Error& from);
  Error(Error&& from) noexcept
    : Error() {
    *this = ::std::move(from);
  }

  inline Error& operator=(const Error& from) {
    CopyFrom(from);
    return *this;
  }
  inline Error& operator=(Error&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Error& default_instance() {
    return *internal_default_instance();
  }
  static inline const Error* internal_default_instance() {
    return reinterpret_cast<const Error*>(
               &_Error_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Error& a, Error& b) {
    a.Swap(&b);
  }
  inline void Swap(Error* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Error* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Error* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Error>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Error& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Error& from) {
    Error::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Error* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Error";
  }
  protected:
  explicit Error(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDesFieldNumber = 2,
  };
  // string des = 2;
  void clear_des();
  const std::string& des() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_des(ArgT0&& arg0, ArgT... args);
  std::string* mutable_des();
  PROTOBUF_NODISCARD std::string* release_des();
  void set_allocated_des(std::string* des);
  private:
  const std::string& _internal_des() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_des(const std::string& value);
  std::string* _internal_mutable_des();
  public:

  // @@protoc_insertion_point(class_scope:Error)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr des_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_serverData_2eproto;
};
// -------------------------------------------------------------------

class UDP_msg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:UDP_msg) */ {
 public:
  inline UDP_msg() : UDP_msg(nullptr) {}
  ~UDP_msg() override;
  explicit PROTOBUF_CONSTEXPR UDP_msg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UDP_msg(const UDP_msg& from);
  UDP_msg(UDP_msg&& from) noexcept
    : UDP_msg() {
    *this = ::std::move(from);
  }

  inline UDP_msg& operator=(const UDP_msg& from) {
    CopyFrom(from);
    return *this;
  }
  inline UDP_msg& operator=(UDP_msg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UDP_msg& default_instance() {
    return *internal_default_instance();
  }
  static inline const UDP_msg* internal_default_instance() {
    return reinterpret_cast<const UDP_msg*>(
               &_UDP_msg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(UDP_msg& a, UDP_msg& b) {
    a.Swap(&b);
  }
  inline void Swap(UDP_msg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UDP_msg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UDP_msg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UDP_msg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UDP_msg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UDP_msg& from) {
    UDP_msg::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UDP_msg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "UDP_msg";
  }
  protected:
  explicit UDP_msg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMPlayerStateFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // optional .PlayerState m_playerState = 2;
  bool has_m_playerstate() const;
  private:
  bool _internal_has_m_playerstate() const;
  public:
  void clear_m_playerstate();
  const ::PlayerState& m_playerstate() const;
  PROTOBUF_NODISCARD ::PlayerState* release_m_playerstate();
  ::PlayerState* mutable_m_playerstate();
  void set_allocated_m_playerstate(::PlayerState* m_playerstate);
  private:
  const ::PlayerState& _internal_m_playerstate() const;
  ::PlayerState* _internal_mutable_m_playerstate();
  public:
  void unsafe_arena_set_allocated_m_playerstate(
      ::PlayerState* m_playerstate);
  ::PlayerState* unsafe_arena_release_m_playerstate();

  // int32 type = 1;
  void clear_type();
  int32_t type() const;
  void set_type(int32_t value);
  private:
  int32_t _internal_type() const;
  void _internal_set_type(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:UDP_msg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PlayerState* m_playerstate_;
    int32_t type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_serverData_2eproto;
};
// -------------------------------------------------------------------

class TCP_msg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TCP_msg) */ {
 public:
  inline TCP_msg() : TCP_msg(nullptr) {}
  ~TCP_msg() override;
  explicit PROTOBUF_CONSTEXPR TCP_msg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TCP_msg(const TCP_msg& from);
  TCP_msg(TCP_msg&& from) noexcept
    : TCP_msg() {
    *this = ::std::move(from);
  }

  inline TCP_msg& operator=(const TCP_msg& from) {
    CopyFrom(from);
    return *this;
  }
  inline TCP_msg& operator=(TCP_msg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TCP_msg& default_instance() {
    return *internal_default_instance();
  }
  static inline const TCP_msg* internal_default_instance() {
    return reinterpret_cast<const TCP_msg*>(
               &_TCP_msg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(TCP_msg& a, TCP_msg& b) {
    a.Swap(&b);
  }
  inline void Swap(TCP_msg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TCP_msg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TCP_msg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TCP_msg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TCP_msg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TCP_msg& from) {
    TCP_msg::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TCP_msg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TCP_msg";
  }
  protected:
  explicit TCP_msg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMLoginFieldNumber = 2,
    kMRegisterFieldNumber = 3,
    kMPlayerMSGFieldNumber = 4,
    kMClientCommandFieldNumber = 5,
    kMErrorFieldNumber = 6,
    kMLogListFieldNumber = 7,
    kMLogInfoFieldNumber = 8,
    kTypeFieldNumber = 1,
  };
  // optional .Login m_login = 2;
  bool has_m_login() const;
  private:
  bool _internal_has_m_login() const;
  public:
  void clear_m_login();
  const ::Login& m_login() const;
  PROTOBUF_NODISCARD ::Login* release_m_login();
  ::Login* mutable_m_login();
  void set_allocated_m_login(::Login* m_login);
  private:
  const ::Login& _internal_m_login() const;
  ::Login* _internal_mutable_m_login();
  public:
  void unsafe_arena_set_allocated_m_login(
      ::Login* m_login);
  ::Login* unsafe_arena_release_m_login();

  // optional .Register m_register = 3;
  bool has_m_register() const;
  private:
  bool _internal_has_m_register() const;
  public:
  void clear_m_register();
  const ::Register& m_register() const;
  PROTOBUF_NODISCARD ::Register* release_m_register();
  ::Register* mutable_m_register();
  void set_allocated_m_register(::Register* m_register);
  private:
  const ::Register& _internal_m_register() const;
  ::Register* _internal_mutable_m_register();
  public:
  void unsafe_arena_set_allocated_m_register(
      ::Register* m_register);
  ::Register* unsafe_arena_release_m_register();

  // optional .PlayerMSG m_playerMSG = 4;
  bool has_m_playermsg() const;
  private:
  bool _internal_has_m_playermsg() const;
  public:
  void clear_m_playermsg();
  const ::PlayerMSG& m_playermsg() const;
  PROTOBUF_NODISCARD ::PlayerMSG* release_m_playermsg();
  ::PlayerMSG* mutable_m_playermsg();
  void set_allocated_m_playermsg(::PlayerMSG* m_playermsg);
  private:
  const ::PlayerMSG& _internal_m_playermsg() const;
  ::PlayerMSG* _internal_mutable_m_playermsg();
  public:
  void unsafe_arena_set_allocated_m_playermsg(
      ::PlayerMSG* m_playermsg);
  ::PlayerMSG* unsafe_arena_release_m_playermsg();

  // optional .ClientCommand m_clientCommand = 5;
  bool has_m_clientcommand() const;
  private:
  bool _internal_has_m_clientcommand() const;
  public:
  void clear_m_clientcommand();
  const ::ClientCommand& m_clientcommand() const;
  PROTOBUF_NODISCARD ::ClientCommand* release_m_clientcommand();
  ::ClientCommand* mutable_m_clientcommand();
  void set_allocated_m_clientcommand(::ClientCommand* m_clientcommand);
  private:
  const ::ClientCommand& _internal_m_clientcommand() const;
  ::ClientCommand* _internal_mutable_m_clientcommand();
  public:
  void unsafe_arena_set_allocated_m_clientcommand(
      ::ClientCommand* m_clientcommand);
  ::ClientCommand* unsafe_arena_release_m_clientcommand();

  // optional .Error m_error = 6;
  bool has_m_error() const;
  private:
  bool _internal_has_m_error() const;
  public:
  void clear_m_error();
  const ::Error& m_error() const;
  PROTOBUF_NODISCARD ::Error* release_m_error();
  ::Error* mutable_m_error();
  void set_allocated_m_error(::Error* m_error);
  private:
  const ::Error& _internal_m_error() const;
  ::Error* _internal_mutable_m_error();
  public:
  void unsafe_arena_set_allocated_m_error(
      ::Error* m_error);
  ::Error* unsafe_arena_release_m_error();

  // optional .LogList m_log_list = 7;
  bool has_m_log_list() const;
  private:
  bool _internal_has_m_log_list() const;
  public:
  void clear_m_log_list();
  const ::LogList& m_log_list() const;
  PROTOBUF_NODISCARD ::LogList* release_m_log_list();
  ::LogList* mutable_m_log_list();
  void set_allocated_m_log_list(::LogList* m_log_list);
  private:
  const ::LogList& _internal_m_log_list() const;
  ::LogList* _internal_mutable_m_log_list();
  public:
  void unsafe_arena_set_allocated_m_log_list(
      ::LogList* m_log_list);
  ::LogList* unsafe_arena_release_m_log_list();

  // optional .Login_Info m_log_info = 8;
  bool has_m_log_info() const;
  private:
  bool _internal_has_m_log_info() const;
  public:
  void clear_m_log_info();
  const ::Login_Info& m_log_info() const;
  PROTOBUF_NODISCARD ::Login_Info* release_m_log_info();
  ::Login_Info* mutable_m_log_info();
  void set_allocated_m_log_info(::Login_Info* m_log_info);
  private:
  const ::Login_Info& _internal_m_log_info() const;
  ::Login_Info* _internal_mutable_m_log_info();
  public:
  void unsafe_arena_set_allocated_m_log_info(
      ::Login_Info* m_log_info);
  ::Login_Info* unsafe_arena_release_m_log_info();

  // int32 type = 1;
  void clear_type();
  int32_t type() const;
  void set_type(int32_t value);
  private:
  int32_t _internal_type() const;
  void _internal_set_type(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:TCP_msg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::Login* m_login_;
    ::Register* m_register_;
    ::PlayerMSG* m_playermsg_;
    ::ClientCommand* m_clientcommand_;
    ::Error* m_error_;
    ::LogList* m_log_list_;
    ::Login_Info* m_log_info_;
    int32_t type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_serverData_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Login

// string ID = 1;
inline void Login::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& Login::id() const {
  // @@protoc_insertion_point(field_get:Login.ID)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Login::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Login.ID)
}
inline std::string* Login::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:Login.ID)
  return _s;
}
inline const std::string& Login::_internal_id() const {
  return _impl_.id_.Get();
}
inline void Login::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* Login::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* Login::release_id() {
  // @@protoc_insertion_point(field_release:Login.ID)
  return _impl_.id_.Release();
}
inline void Login::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Login.ID)
}

// string password = 2;
inline void Login::clear_password() {
  _impl_.password_.ClearToEmpty();
}
inline const std::string& Login::password() const {
  // @@protoc_insertion_point(field_get:Login.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Login::set_password(ArgT0&& arg0, ArgT... args) {
 
 _impl_.password_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Login.password)
}
inline std::string* Login::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:Login.password)
  return _s;
}
inline const std::string& Login::_internal_password() const {
  return _impl_.password_.Get();
}
inline void Login::_internal_set_password(const std::string& value) {
  
  _impl_.password_.Set(value, GetArenaForAllocation());
}
inline std::string* Login::_internal_mutable_password() {
  
  return _impl_.password_.Mutable(GetArenaForAllocation());
}
inline std::string* Login::release_password() {
  // @@protoc_insertion_point(field_release:Login.password)
  return _impl_.password_.Release();
}
inline void Login::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  _impl_.password_.SetAllocated(password, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.password_.IsDefault()) {
    _impl_.password_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Login.password)
}

// -------------------------------------------------------------------

// Register

// string ID = 1;
inline void Register::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& Register::id() const {
  // @@protoc_insertion_point(field_get:Register.ID)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Register::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Register.ID)
}
inline std::string* Register::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:Register.ID)
  return _s;
}
inline const std::string& Register::_internal_id() const {
  return _impl_.id_.Get();
}
inline void Register::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* Register::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* Register::release_id() {
  // @@protoc_insertion_point(field_release:Register.ID)
  return _impl_.id_.Release();
}
inline void Register::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Register.ID)
}

// string password = 2;
inline void Register::clear_password() {
  _impl_.password_.ClearToEmpty();
}
inline const std::string& Register::password() const {
  // @@protoc_insertion_point(field_get:Register.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Register::set_password(ArgT0&& arg0, ArgT... args) {
 
 _impl_.password_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Register.password)
}
inline std::string* Register::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:Register.password)
  return _s;
}
inline const std::string& Register::_internal_password() const {
  return _impl_.password_.Get();
}
inline void Register::_internal_set_password(const std::string& value) {
  
  _impl_.password_.Set(value, GetArenaForAllocation());
}
inline std::string* Register::_internal_mutable_password() {
  
  return _impl_.password_.Mutable(GetArenaForAllocation());
}
inline std::string* Register::release_password() {
  // @@protoc_insertion_point(field_release:Register.password)
  return _impl_.password_.Release();
}
inline void Register::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  _impl_.password_.SetAllocated(password, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.password_.IsDefault()) {
    _impl_.password_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Register.password)
}

// -------------------------------------------------------------------

// PlayerMSG

// string msg = 1;
inline void PlayerMSG::clear_msg() {
  _impl_.msg_.ClearToEmpty();
}
inline const std::string& PlayerMSG::msg() const {
  // @@protoc_insertion_point(field_get:PlayerMSG.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PlayerMSG::set_msg(ArgT0&& arg0, ArgT... args) {
 
 _impl_.msg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PlayerMSG.msg)
}
inline std::string* PlayerMSG::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:PlayerMSG.msg)
  return _s;
}
inline const std::string& PlayerMSG::_internal_msg() const {
  return _impl_.msg_.Get();
}
inline void PlayerMSG::_internal_set_msg(const std::string& value) {
  
  _impl_.msg_.Set(value, GetArenaForAllocation());
}
inline std::string* PlayerMSG::_internal_mutable_msg() {
  
  return _impl_.msg_.Mutable(GetArenaForAllocation());
}
inline std::string* PlayerMSG::release_msg() {
  // @@protoc_insertion_point(field_release:PlayerMSG.msg)
  return _impl_.msg_.Release();
}
inline void PlayerMSG::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  _impl_.msg_.SetAllocated(msg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_.IsDefault()) {
    _impl_.msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PlayerMSG.msg)
}

// -------------------------------------------------------------------

// CharacterLog

// string name = 1;
inline void CharacterLog::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& CharacterLog::name() const {
  // @@protoc_insertion_point(field_get:CharacterLog.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CharacterLog::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CharacterLog.name)
}
inline std::string* CharacterLog::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:CharacterLog.name)
  return _s;
}
inline const std::string& CharacterLog::_internal_name() const {
  return _impl_.name_.Get();
}
inline void CharacterLog::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* CharacterLog::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* CharacterLog::release_name() {
  // @@protoc_insertion_point(field_release:CharacterLog.name)
  return _impl_.name_.Release();
}
inline void CharacterLog::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CharacterLog.name)
}

// string location = 2;
inline void CharacterLog::clear_location() {
  _impl_.location_.ClearToEmpty();
}
inline const std::string& CharacterLog::location() const {
  // @@protoc_insertion_point(field_get:CharacterLog.location)
  return _internal_location();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CharacterLog::set_location(ArgT0&& arg0, ArgT... args) {
 
 _impl_.location_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CharacterLog.location)
}
inline std::string* CharacterLog::mutable_location() {
  std::string* _s = _internal_mutable_location();
  // @@protoc_insertion_point(field_mutable:CharacterLog.location)
  return _s;
}
inline const std::string& CharacterLog::_internal_location() const {
  return _impl_.location_.Get();
}
inline void CharacterLog::_internal_set_location(const std::string& value) {
  
  _impl_.location_.Set(value, GetArenaForAllocation());
}
inline std::string* CharacterLog::_internal_mutable_location() {
  
  return _impl_.location_.Mutable(GetArenaForAllocation());
}
inline std::string* CharacterLog::release_location() {
  // @@protoc_insertion_point(field_release:CharacterLog.location)
  return _impl_.location_.Release();
}
inline void CharacterLog::set_allocated_location(std::string* location) {
  if (location != nullptr) {
    
  } else {
    
  }
  _impl_.location_.SetAllocated(location, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.location_.IsDefault()) {
    _impl_.location_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CharacterLog.location)
}

// float x_pos = 3;
inline void CharacterLog::clear_x_pos() {
  _impl_.x_pos_ = 0;
}
inline float CharacterLog::_internal_x_pos() const {
  return _impl_.x_pos_;
}
inline float CharacterLog::x_pos() const {
  // @@protoc_insertion_point(field_get:CharacterLog.x_pos)
  return _internal_x_pos();
}
inline void CharacterLog::_internal_set_x_pos(float value) {
  
  _impl_.x_pos_ = value;
}
inline void CharacterLog::set_x_pos(float value) {
  _internal_set_x_pos(value);
  // @@protoc_insertion_point(field_set:CharacterLog.x_pos)
}

// float y_pos = 4;
inline void CharacterLog::clear_y_pos() {
  _impl_.y_pos_ = 0;
}
inline float CharacterLog::_internal_y_pos() const {
  return _impl_.y_pos_;
}
inline float CharacterLog::y_pos() const {
  // @@protoc_insertion_point(field_get:CharacterLog.y_pos)
  return _internal_y_pos();
}
inline void CharacterLog::_internal_set_y_pos(float value) {
  
  _impl_.y_pos_ = value;
}
inline void CharacterLog::set_y_pos(float value) {
  _internal_set_y_pos(value);
  // @@protoc_insertion_point(field_set:CharacterLog.y_pos)
}

// -------------------------------------------------------------------

// LogList

// repeated .CharacterLog list = 1;
inline int LogList::_internal_list_size() const {
  return _impl_.list_.size();
}
inline int LogList::list_size() const {
  return _internal_list_size();
}
inline void LogList::clear_list() {
  _impl_.list_.Clear();
}
inline ::CharacterLog* LogList::mutable_list(int index) {
  // @@protoc_insertion_point(field_mutable:LogList.list)
  return _impl_.list_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CharacterLog >*
LogList::mutable_list() {
  // @@protoc_insertion_point(field_mutable_list:LogList.list)
  return &_impl_.list_;
}
inline const ::CharacterLog& LogList::_internal_list(int index) const {
  return _impl_.list_.Get(index);
}
inline const ::CharacterLog& LogList::list(int index) const {
  // @@protoc_insertion_point(field_get:LogList.list)
  return _internal_list(index);
}
inline ::CharacterLog* LogList::_internal_add_list() {
  return _impl_.list_.Add();
}
inline ::CharacterLog* LogList::add_list() {
  ::CharacterLog* _add = _internal_add_list();
  // @@protoc_insertion_point(field_add:LogList.list)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CharacterLog >&
LogList::list() const {
  // @@protoc_insertion_point(field_list:LogList.list)
  return _impl_.list_;
}

// -------------------------------------------------------------------

// PlayerState

// string name = 1;
inline void PlayerState::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& PlayerState::name() const {
  // @@protoc_insertion_point(field_get:PlayerState.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PlayerState::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PlayerState.name)
}
inline std::string* PlayerState::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:PlayerState.name)
  return _s;
}
inline const std::string& PlayerState::_internal_name() const {
  return _impl_.name_.Get();
}
inline void PlayerState::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* PlayerState::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* PlayerState::release_name() {
  // @@protoc_insertion_point(field_release:PlayerState.name)
  return _impl_.name_.Release();
}
inline void PlayerState::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PlayerState.name)
}

// int32 action = 2;
inline void PlayerState::clear_action() {
  _impl_.action_ = 0;
}
inline int32_t PlayerState::_internal_action() const {
  return _impl_.action_;
}
inline int32_t PlayerState::action() const {
  // @@protoc_insertion_point(field_get:PlayerState.action)
  return _internal_action();
}
inline void PlayerState::_internal_set_action(int32_t value) {
  
  _impl_.action_ = value;
}
inline void PlayerState::set_action(int32_t value) {
  _internal_set_action(value);
  // @@protoc_insertion_point(field_set:PlayerState.action)
}

// float x_pos = 3;
inline void PlayerState::clear_x_pos() {
  _impl_.x_pos_ = 0;
}
inline float PlayerState::_internal_x_pos() const {
  return _impl_.x_pos_;
}
inline float PlayerState::x_pos() const {
  // @@protoc_insertion_point(field_get:PlayerState.x_pos)
  return _internal_x_pos();
}
inline void PlayerState::_internal_set_x_pos(float value) {
  
  _impl_.x_pos_ = value;
}
inline void PlayerState::set_x_pos(float value) {
  _internal_set_x_pos(value);
  // @@protoc_insertion_point(field_set:PlayerState.x_pos)
}

// float y_pos = 4;
inline void PlayerState::clear_y_pos() {
  _impl_.y_pos_ = 0;
}
inline float PlayerState::_internal_y_pos() const {
  return _impl_.y_pos_;
}
inline float PlayerState::y_pos() const {
  // @@protoc_insertion_point(field_get:PlayerState.y_pos)
  return _internal_y_pos();
}
inline void PlayerState::_internal_set_y_pos(float value) {
  
  _impl_.y_pos_ = value;
}
inline void PlayerState::set_y_pos(float value) {
  _internal_set_y_pos(value);
  // @@protoc_insertion_point(field_set:PlayerState.y_pos)
}

// -------------------------------------------------------------------

// Login_Info

// string ID = 1;
inline void Login_Info::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& Login_Info::id() const {
  // @@protoc_insertion_point(field_get:Login_Info.ID)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Login_Info::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Login_Info.ID)
}
inline std::string* Login_Info::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:Login_Info.ID)
  return _s;
}
inline const std::string& Login_Info::_internal_id() const {
  return _impl_.id_.Get();
}
inline void Login_Info::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* Login_Info::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* Login_Info::release_id() {
  // @@protoc_insertion_point(field_release:Login_Info.ID)
  return _impl_.id_.Release();
}
inline void Login_Info::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Login_Info.ID)
}

// -------------------------------------------------------------------

// ClientCommand

// string command = 1;
inline void ClientCommand::clear_command() {
  _impl_.command_.ClearToEmpty();
}
inline const std::string& ClientCommand::command() const {
  // @@protoc_insertion_point(field_get:ClientCommand.command)
  return _internal_command();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ClientCommand::set_command(ArgT0&& arg0, ArgT... args) {
 
 _impl_.command_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ClientCommand.command)
}
inline std::string* ClientCommand::mutable_command() {
  std::string* _s = _internal_mutable_command();
  // @@protoc_insertion_point(field_mutable:ClientCommand.command)
  return _s;
}
inline const std::string& ClientCommand::_internal_command() const {
  return _impl_.command_.Get();
}
inline void ClientCommand::_internal_set_command(const std::string& value) {
  
  _impl_.command_.Set(value, GetArenaForAllocation());
}
inline std::string* ClientCommand::_internal_mutable_command() {
  
  return _impl_.command_.Mutable(GetArenaForAllocation());
}
inline std::string* ClientCommand::release_command() {
  // @@protoc_insertion_point(field_release:ClientCommand.command)
  return _impl_.command_.Release();
}
inline void ClientCommand::set_allocated_command(std::string* command) {
  if (command != nullptr) {
    
  } else {
    
  }
  _impl_.command_.SetAllocated(command, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.command_.IsDefault()) {
    _impl_.command_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ClientCommand.command)
}

// -------------------------------------------------------------------

// Error

// string des = 2;
inline void Error::clear_des() {
  _impl_.des_.ClearToEmpty();
}
inline const std::string& Error::des() const {
  // @@protoc_insertion_point(field_get:Error.des)
  return _internal_des();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Error::set_des(ArgT0&& arg0, ArgT... args) {
 
 _impl_.des_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Error.des)
}
inline std::string* Error::mutable_des() {
  std::string* _s = _internal_mutable_des();
  // @@protoc_insertion_point(field_mutable:Error.des)
  return _s;
}
inline const std::string& Error::_internal_des() const {
  return _impl_.des_.Get();
}
inline void Error::_internal_set_des(const std::string& value) {
  
  _impl_.des_.Set(value, GetArenaForAllocation());
}
inline std::string* Error::_internal_mutable_des() {
  
  return _impl_.des_.Mutable(GetArenaForAllocation());
}
inline std::string* Error::release_des() {
  // @@protoc_insertion_point(field_release:Error.des)
  return _impl_.des_.Release();
}
inline void Error::set_allocated_des(std::string* des) {
  if (des != nullptr) {
    
  } else {
    
  }
  _impl_.des_.SetAllocated(des, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.des_.IsDefault()) {
    _impl_.des_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Error.des)
}

// -------------------------------------------------------------------

// UDP_msg

// int32 type = 1;
inline void UDP_msg::clear_type() {
  _impl_.type_ = 0;
}
inline int32_t UDP_msg::_internal_type() const {
  return _impl_.type_;
}
inline int32_t UDP_msg::type() const {
  // @@protoc_insertion_point(field_get:UDP_msg.type)
  return _internal_type();
}
inline void UDP_msg::_internal_set_type(int32_t value) {
  
  _impl_.type_ = value;
}
inline void UDP_msg::set_type(int32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:UDP_msg.type)
}

// optional .PlayerState m_playerState = 2;
inline bool UDP_msg::_internal_has_m_playerstate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.m_playerstate_ != nullptr);
  return value;
}
inline bool UDP_msg::has_m_playerstate() const {
  return _internal_has_m_playerstate();
}
inline void UDP_msg::clear_m_playerstate() {
  if (_impl_.m_playerstate_ != nullptr) _impl_.m_playerstate_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::PlayerState& UDP_msg::_internal_m_playerstate() const {
  const ::PlayerState* p = _impl_.m_playerstate_;
  return p != nullptr ? *p : reinterpret_cast<const ::PlayerState&>(
      ::_PlayerState_default_instance_);
}
inline const ::PlayerState& UDP_msg::m_playerstate() const {
  // @@protoc_insertion_point(field_get:UDP_msg.m_playerState)
  return _internal_m_playerstate();
}
inline void UDP_msg::unsafe_arena_set_allocated_m_playerstate(
    ::PlayerState* m_playerstate) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.m_playerstate_);
  }
  _impl_.m_playerstate_ = m_playerstate;
  if (m_playerstate) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:UDP_msg.m_playerState)
}
inline ::PlayerState* UDP_msg::release_m_playerstate() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::PlayerState* temp = _impl_.m_playerstate_;
  _impl_.m_playerstate_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PlayerState* UDP_msg::unsafe_arena_release_m_playerstate() {
  // @@protoc_insertion_point(field_release:UDP_msg.m_playerState)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::PlayerState* temp = _impl_.m_playerstate_;
  _impl_.m_playerstate_ = nullptr;
  return temp;
}
inline ::PlayerState* UDP_msg::_internal_mutable_m_playerstate() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.m_playerstate_ == nullptr) {
    auto* p = CreateMaybeMessage<::PlayerState>(GetArenaForAllocation());
    _impl_.m_playerstate_ = p;
  }
  return _impl_.m_playerstate_;
}
inline ::PlayerState* UDP_msg::mutable_m_playerstate() {
  ::PlayerState* _msg = _internal_mutable_m_playerstate();
  // @@protoc_insertion_point(field_mutable:UDP_msg.m_playerState)
  return _msg;
}
inline void UDP_msg::set_allocated_m_playerstate(::PlayerState* m_playerstate) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.m_playerstate_;
  }
  if (m_playerstate) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(m_playerstate);
    if (message_arena != submessage_arena) {
      m_playerstate = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, m_playerstate, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.m_playerstate_ = m_playerstate;
  // @@protoc_insertion_point(field_set_allocated:UDP_msg.m_playerState)
}

// -------------------------------------------------------------------

// TCP_msg

// int32 type = 1;
inline void TCP_msg::clear_type() {
  _impl_.type_ = 0;
}
inline int32_t TCP_msg::_internal_type() const {
  return _impl_.type_;
}
inline int32_t TCP_msg::type() const {
  // @@protoc_insertion_point(field_get:TCP_msg.type)
  return _internal_type();
}
inline void TCP_msg::_internal_set_type(int32_t value) {
  
  _impl_.type_ = value;
}
inline void TCP_msg::set_type(int32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:TCP_msg.type)
}

// optional .Login m_login = 2;
inline bool TCP_msg::_internal_has_m_login() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.m_login_ != nullptr);
  return value;
}
inline bool TCP_msg::has_m_login() const {
  return _internal_has_m_login();
}
inline void TCP_msg::clear_m_login() {
  if (_impl_.m_login_ != nullptr) _impl_.m_login_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::Login& TCP_msg::_internal_m_login() const {
  const ::Login* p = _impl_.m_login_;
  return p != nullptr ? *p : reinterpret_cast<const ::Login&>(
      ::_Login_default_instance_);
}
inline const ::Login& TCP_msg::m_login() const {
  // @@protoc_insertion_point(field_get:TCP_msg.m_login)
  return _internal_m_login();
}
inline void TCP_msg::unsafe_arena_set_allocated_m_login(
    ::Login* m_login) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.m_login_);
  }
  _impl_.m_login_ = m_login;
  if (m_login) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TCP_msg.m_login)
}
inline ::Login* TCP_msg::release_m_login() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Login* temp = _impl_.m_login_;
  _impl_.m_login_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Login* TCP_msg::unsafe_arena_release_m_login() {
  // @@protoc_insertion_point(field_release:TCP_msg.m_login)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Login* temp = _impl_.m_login_;
  _impl_.m_login_ = nullptr;
  return temp;
}
inline ::Login* TCP_msg::_internal_mutable_m_login() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.m_login_ == nullptr) {
    auto* p = CreateMaybeMessage<::Login>(GetArenaForAllocation());
    _impl_.m_login_ = p;
  }
  return _impl_.m_login_;
}
inline ::Login* TCP_msg::mutable_m_login() {
  ::Login* _msg = _internal_mutable_m_login();
  // @@protoc_insertion_point(field_mutable:TCP_msg.m_login)
  return _msg;
}
inline void TCP_msg::set_allocated_m_login(::Login* m_login) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.m_login_;
  }
  if (m_login) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(m_login);
    if (message_arena != submessage_arena) {
      m_login = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, m_login, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.m_login_ = m_login;
  // @@protoc_insertion_point(field_set_allocated:TCP_msg.m_login)
}

// optional .Register m_register = 3;
inline bool TCP_msg::_internal_has_m_register() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.m_register_ != nullptr);
  return value;
}
inline bool TCP_msg::has_m_register() const {
  return _internal_has_m_register();
}
inline void TCP_msg::clear_m_register() {
  if (_impl_.m_register_ != nullptr) _impl_.m_register_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::Register& TCP_msg::_internal_m_register() const {
  const ::Register* p = _impl_.m_register_;
  return p != nullptr ? *p : reinterpret_cast<const ::Register&>(
      ::_Register_default_instance_);
}
inline const ::Register& TCP_msg::m_register() const {
  // @@protoc_insertion_point(field_get:TCP_msg.m_register)
  return _internal_m_register();
}
inline void TCP_msg::unsafe_arena_set_allocated_m_register(
    ::Register* m_register) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.m_register_);
  }
  _impl_.m_register_ = m_register;
  if (m_register) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TCP_msg.m_register)
}
inline ::Register* TCP_msg::release_m_register() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::Register* temp = _impl_.m_register_;
  _impl_.m_register_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Register* TCP_msg::unsafe_arena_release_m_register() {
  // @@protoc_insertion_point(field_release:TCP_msg.m_register)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::Register* temp = _impl_.m_register_;
  _impl_.m_register_ = nullptr;
  return temp;
}
inline ::Register* TCP_msg::_internal_mutable_m_register() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.m_register_ == nullptr) {
    auto* p = CreateMaybeMessage<::Register>(GetArenaForAllocation());
    _impl_.m_register_ = p;
  }
  return _impl_.m_register_;
}
inline ::Register* TCP_msg::mutable_m_register() {
  ::Register* _msg = _internal_mutable_m_register();
  // @@protoc_insertion_point(field_mutable:TCP_msg.m_register)
  return _msg;
}
inline void TCP_msg::set_allocated_m_register(::Register* m_register) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.m_register_;
  }
  if (m_register) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(m_register);
    if (message_arena != submessage_arena) {
      m_register = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, m_register, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.m_register_ = m_register;
  // @@protoc_insertion_point(field_set_allocated:TCP_msg.m_register)
}

// optional .PlayerMSG m_playerMSG = 4;
inline bool TCP_msg::_internal_has_m_playermsg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.m_playermsg_ != nullptr);
  return value;
}
inline bool TCP_msg::has_m_playermsg() const {
  return _internal_has_m_playermsg();
}
inline void TCP_msg::clear_m_playermsg() {
  if (_impl_.m_playermsg_ != nullptr) _impl_.m_playermsg_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::PlayerMSG& TCP_msg::_internal_m_playermsg() const {
  const ::PlayerMSG* p = _impl_.m_playermsg_;
  return p != nullptr ? *p : reinterpret_cast<const ::PlayerMSG&>(
      ::_PlayerMSG_default_instance_);
}
inline const ::PlayerMSG& TCP_msg::m_playermsg() const {
  // @@protoc_insertion_point(field_get:TCP_msg.m_playerMSG)
  return _internal_m_playermsg();
}
inline void TCP_msg::unsafe_arena_set_allocated_m_playermsg(
    ::PlayerMSG* m_playermsg) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.m_playermsg_);
  }
  _impl_.m_playermsg_ = m_playermsg;
  if (m_playermsg) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TCP_msg.m_playerMSG)
}
inline ::PlayerMSG* TCP_msg::release_m_playermsg() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::PlayerMSG* temp = _impl_.m_playermsg_;
  _impl_.m_playermsg_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PlayerMSG* TCP_msg::unsafe_arena_release_m_playermsg() {
  // @@protoc_insertion_point(field_release:TCP_msg.m_playerMSG)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::PlayerMSG* temp = _impl_.m_playermsg_;
  _impl_.m_playermsg_ = nullptr;
  return temp;
}
inline ::PlayerMSG* TCP_msg::_internal_mutable_m_playermsg() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.m_playermsg_ == nullptr) {
    auto* p = CreateMaybeMessage<::PlayerMSG>(GetArenaForAllocation());
    _impl_.m_playermsg_ = p;
  }
  return _impl_.m_playermsg_;
}
inline ::PlayerMSG* TCP_msg::mutable_m_playermsg() {
  ::PlayerMSG* _msg = _internal_mutable_m_playermsg();
  // @@protoc_insertion_point(field_mutable:TCP_msg.m_playerMSG)
  return _msg;
}
inline void TCP_msg::set_allocated_m_playermsg(::PlayerMSG* m_playermsg) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.m_playermsg_;
  }
  if (m_playermsg) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(m_playermsg);
    if (message_arena != submessage_arena) {
      m_playermsg = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, m_playermsg, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.m_playermsg_ = m_playermsg;
  // @@protoc_insertion_point(field_set_allocated:TCP_msg.m_playerMSG)
}

// optional .ClientCommand m_clientCommand = 5;
inline bool TCP_msg::_internal_has_m_clientcommand() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.m_clientcommand_ != nullptr);
  return value;
}
inline bool TCP_msg::has_m_clientcommand() const {
  return _internal_has_m_clientcommand();
}
inline void TCP_msg::clear_m_clientcommand() {
  if (_impl_.m_clientcommand_ != nullptr) _impl_.m_clientcommand_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::ClientCommand& TCP_msg::_internal_m_clientcommand() const {
  const ::ClientCommand* p = _impl_.m_clientcommand_;
  return p != nullptr ? *p : reinterpret_cast<const ::ClientCommand&>(
      ::_ClientCommand_default_instance_);
}
inline const ::ClientCommand& TCP_msg::m_clientcommand() const {
  // @@protoc_insertion_point(field_get:TCP_msg.m_clientCommand)
  return _internal_m_clientcommand();
}
inline void TCP_msg::unsafe_arena_set_allocated_m_clientcommand(
    ::ClientCommand* m_clientcommand) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.m_clientcommand_);
  }
  _impl_.m_clientcommand_ = m_clientcommand;
  if (m_clientcommand) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TCP_msg.m_clientCommand)
}
inline ::ClientCommand* TCP_msg::release_m_clientcommand() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::ClientCommand* temp = _impl_.m_clientcommand_;
  _impl_.m_clientcommand_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ClientCommand* TCP_msg::unsafe_arena_release_m_clientcommand() {
  // @@protoc_insertion_point(field_release:TCP_msg.m_clientCommand)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::ClientCommand* temp = _impl_.m_clientcommand_;
  _impl_.m_clientcommand_ = nullptr;
  return temp;
}
inline ::ClientCommand* TCP_msg::_internal_mutable_m_clientcommand() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.m_clientcommand_ == nullptr) {
    auto* p = CreateMaybeMessage<::ClientCommand>(GetArenaForAllocation());
    _impl_.m_clientcommand_ = p;
  }
  return _impl_.m_clientcommand_;
}
inline ::ClientCommand* TCP_msg::mutable_m_clientcommand() {
  ::ClientCommand* _msg = _internal_mutable_m_clientcommand();
  // @@protoc_insertion_point(field_mutable:TCP_msg.m_clientCommand)
  return _msg;
}
inline void TCP_msg::set_allocated_m_clientcommand(::ClientCommand* m_clientcommand) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.m_clientcommand_;
  }
  if (m_clientcommand) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(m_clientcommand);
    if (message_arena != submessage_arena) {
      m_clientcommand = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, m_clientcommand, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.m_clientcommand_ = m_clientcommand;
  // @@protoc_insertion_point(field_set_allocated:TCP_msg.m_clientCommand)
}

// optional .Error m_error = 6;
inline bool TCP_msg::_internal_has_m_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.m_error_ != nullptr);
  return value;
}
inline bool TCP_msg::has_m_error() const {
  return _internal_has_m_error();
}
inline void TCP_msg::clear_m_error() {
  if (_impl_.m_error_ != nullptr) _impl_.m_error_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::Error& TCP_msg::_internal_m_error() const {
  const ::Error* p = _impl_.m_error_;
  return p != nullptr ? *p : reinterpret_cast<const ::Error&>(
      ::_Error_default_instance_);
}
inline const ::Error& TCP_msg::m_error() const {
  // @@protoc_insertion_point(field_get:TCP_msg.m_error)
  return _internal_m_error();
}
inline void TCP_msg::unsafe_arena_set_allocated_m_error(
    ::Error* m_error) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.m_error_);
  }
  _impl_.m_error_ = m_error;
  if (m_error) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TCP_msg.m_error)
}
inline ::Error* TCP_msg::release_m_error() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::Error* temp = _impl_.m_error_;
  _impl_.m_error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Error* TCP_msg::unsafe_arena_release_m_error() {
  // @@protoc_insertion_point(field_release:TCP_msg.m_error)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::Error* temp = _impl_.m_error_;
  _impl_.m_error_ = nullptr;
  return temp;
}
inline ::Error* TCP_msg::_internal_mutable_m_error() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.m_error_ == nullptr) {
    auto* p = CreateMaybeMessage<::Error>(GetArenaForAllocation());
    _impl_.m_error_ = p;
  }
  return _impl_.m_error_;
}
inline ::Error* TCP_msg::mutable_m_error() {
  ::Error* _msg = _internal_mutable_m_error();
  // @@protoc_insertion_point(field_mutable:TCP_msg.m_error)
  return _msg;
}
inline void TCP_msg::set_allocated_m_error(::Error* m_error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.m_error_;
  }
  if (m_error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(m_error);
    if (message_arena != submessage_arena) {
      m_error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, m_error, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.m_error_ = m_error;
  // @@protoc_insertion_point(field_set_allocated:TCP_msg.m_error)
}

// optional .LogList m_log_list = 7;
inline bool TCP_msg::_internal_has_m_log_list() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.m_log_list_ != nullptr);
  return value;
}
inline bool TCP_msg::has_m_log_list() const {
  return _internal_has_m_log_list();
}
inline void TCP_msg::clear_m_log_list() {
  if (_impl_.m_log_list_ != nullptr) _impl_.m_log_list_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::LogList& TCP_msg::_internal_m_log_list() const {
  const ::LogList* p = _impl_.m_log_list_;
  return p != nullptr ? *p : reinterpret_cast<const ::LogList&>(
      ::_LogList_default_instance_);
}
inline const ::LogList& TCP_msg::m_log_list() const {
  // @@protoc_insertion_point(field_get:TCP_msg.m_log_list)
  return _internal_m_log_list();
}
inline void TCP_msg::unsafe_arena_set_allocated_m_log_list(
    ::LogList* m_log_list) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.m_log_list_);
  }
  _impl_.m_log_list_ = m_log_list;
  if (m_log_list) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TCP_msg.m_log_list)
}
inline ::LogList* TCP_msg::release_m_log_list() {
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::LogList* temp = _impl_.m_log_list_;
  _impl_.m_log_list_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::LogList* TCP_msg::unsafe_arena_release_m_log_list() {
  // @@protoc_insertion_point(field_release:TCP_msg.m_log_list)
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::LogList* temp = _impl_.m_log_list_;
  _impl_.m_log_list_ = nullptr;
  return temp;
}
inline ::LogList* TCP_msg::_internal_mutable_m_log_list() {
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.m_log_list_ == nullptr) {
    auto* p = CreateMaybeMessage<::LogList>(GetArenaForAllocation());
    _impl_.m_log_list_ = p;
  }
  return _impl_.m_log_list_;
}
inline ::LogList* TCP_msg::mutable_m_log_list() {
  ::LogList* _msg = _internal_mutable_m_log_list();
  // @@protoc_insertion_point(field_mutable:TCP_msg.m_log_list)
  return _msg;
}
inline void TCP_msg::set_allocated_m_log_list(::LogList* m_log_list) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.m_log_list_;
  }
  if (m_log_list) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(m_log_list);
    if (message_arena != submessage_arena) {
      m_log_list = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, m_log_list, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.m_log_list_ = m_log_list;
  // @@protoc_insertion_point(field_set_allocated:TCP_msg.m_log_list)
}

// optional .Login_Info m_log_info = 8;
inline bool TCP_msg::_internal_has_m_log_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.m_log_info_ != nullptr);
  return value;
}
inline bool TCP_msg::has_m_log_info() const {
  return _internal_has_m_log_info();
}
inline void TCP_msg::clear_m_log_info() {
  if (_impl_.m_log_info_ != nullptr) _impl_.m_log_info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const ::Login_Info& TCP_msg::_internal_m_log_info() const {
  const ::Login_Info* p = _impl_.m_log_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::Login_Info&>(
      ::_Login_Info_default_instance_);
}
inline const ::Login_Info& TCP_msg::m_log_info() const {
  // @@protoc_insertion_point(field_get:TCP_msg.m_log_info)
  return _internal_m_log_info();
}
inline void TCP_msg::unsafe_arena_set_allocated_m_log_info(
    ::Login_Info* m_log_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.m_log_info_);
  }
  _impl_.m_log_info_ = m_log_info;
  if (m_log_info) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TCP_msg.m_log_info)
}
inline ::Login_Info* TCP_msg::release_m_log_info() {
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::Login_Info* temp = _impl_.m_log_info_;
  _impl_.m_log_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Login_Info* TCP_msg::unsafe_arena_release_m_log_info() {
  // @@protoc_insertion_point(field_release:TCP_msg.m_log_info)
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::Login_Info* temp = _impl_.m_log_info_;
  _impl_.m_log_info_ = nullptr;
  return temp;
}
inline ::Login_Info* TCP_msg::_internal_mutable_m_log_info() {
  _impl_._has_bits_[0] |= 0x00000040u;
  if (_impl_.m_log_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::Login_Info>(GetArenaForAllocation());
    _impl_.m_log_info_ = p;
  }
  return _impl_.m_log_info_;
}
inline ::Login_Info* TCP_msg::mutable_m_log_info() {
  ::Login_Info* _msg = _internal_mutable_m_log_info();
  // @@protoc_insertion_point(field_mutable:TCP_msg.m_log_info)
  return _msg;
}
inline void TCP_msg::set_allocated_m_log_info(::Login_Info* m_log_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.m_log_info_;
  }
  if (m_log_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(m_log_info);
    if (message_arena != submessage_arena) {
      m_log_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, m_log_info, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.m_log_info_ = m_log_info;
  // @@protoc_insertion_point(field_set_allocated:TCP_msg.m_log_info)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_serverData_2eproto
